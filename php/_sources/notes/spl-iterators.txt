.. include:: <isopub.txt>

.. role:: kurt-code

Standard PHP Library
====================

Iterators 
---------

Iterator interface
^^^^^^^^^^^^^^^^^^

The ``Iterator`` interface allows an object to be used in ``foreach`` loops. 

.. code-block:: java

    interface Iterator { // conceptual definitions
        public function mixed current ( void );
        public function scalar key ( void );
        public function void next ( void );
        public function void rewind ( void );
        public function boolean valid ( void );
    }
    
    class MyContainer implements Iterator {
       //...snip 
    }

     $x = new MyClass(); // implements Iterator
     //...add some elements
     // iterate using ``foreach``
     foreach($x as $element) {

         echo $element . "\n"; 
     }    

The code below demonstates the order of Iterator method calls that happened in the ``foreach`` loop above.

.. code-block:: php

    <?php
     for( $x->rewind(); $x->valid(); $x->next()) {  // called each time

        $element =  $x->current(); 
        echo $element; 
     }    

This code shows how to implement an iterator for an array.

.. _arrayIterator:

.. code-block:: php

    <?php
    class arrayIterator implements Iterator {

        private $a;
    
        public function __construct(&$a)
        {
           $this->a = $a;
        }
    
        public function valid()
        {
           return valid($this->a);
        }
        
        public function next()
        {
           next($this->a);
           return;     
        }
        
        public function current()
        {
           return current($this->a);
        }
        
        public function rewind()
        {
           reset($this->a);   
        }
        
        public function key()
        {
           return key($this->a);   
        }
    }

And we would use it like so:

.. code-block:: php

    <?php
     $a = array('a' => "apple", 'b' => "bear", 'c' => "camel");

     $iter = new arrayIterator($a);
     foreach($iter as $key => $value) {

         echo "$key = $value\n";
     }     

iterator_apply( $it, 'callback', array($it) ) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Applies a callback to an objects that implements ``Iterator``:

.. code-block:: php

    <?php    
    function print_caps(Iterator $iterator) {
        echo strtoupper($iterator->current()) . "\n";
        return TRUE;
    }
    
    $it = new ArrayIterator(array("Apples", "Bananas", "Cherries"));
    iterator_apply($it, "print_caps", array($it));

IteratorAggregate interface
^^^^^^^^^^^^^^^^^^^^^^^^^^^

``IteratorAggregate`` lets you implement your iterator externally.

.. code-block:: java

    class MyContainer implements IteratorAggregate {
       public function getIterator() { return new MyExternalIterator($this); }
    }

    class MyExternalIterator implements Iterator {
     //...snip
        public function __construct(MyContainer $member)
        {
          // Store $member locally for iteration
        }
    
        // Implementations for: current(), key(), next(), rewind() and valid() to iterate over data in $member
    }

``foreach`` implicitly calls **getIterator()** 

.. code-block:: php

    <?php
     $x = new SomeClass(); // implements IteratorAggregate
     //...add some elements
     // iterate using ``foreach``
     ``foreach`` ($x as $element) { // calls SomeClass::getIterator()

         echo $element . "\n"; 
     }    

The Composite Pattern can be implemented using IteratorAggregate. Below class Menu is the composite class. It implements IteratorAggregate to return an external iterator. 
The base class class of the containment hierarchy is MenuComponent. It too implements IteratorAggregate and returns an instance of NullIterator.

In the code below The Menu::__toString() method invokes foreach on its componentsâ€”either submenus or menu items.

.. code-block:: php

    <?php
    abstract class MenuComponent implements IteratorAggregate {
    
         public function add(MenuComponent  $m)
         {
             throw new \Exception("method MenuComponent::add not implemented");
         }
         public function remove(MenuComponent $m)
         {
             throw new \Exception("method MenuComponent::remove not implemented");
         }

         public function getName()
         {
             throw new \Exception("method MenuComponent::getName not implemented");
         }
         public function getDescription()
         {
             throw new \Exception("method MenuComponent::getDescription  not implemented");
         }
         public function getPrice()
         {
             throw new \Exception("method MenuComponent::getPrice not implemented");
         }
         public function isVegetarian()
         {
             throw new \Exception("method MenuComponent::isVegetarian not implemented");
         }
         public function getIterator()
         {
              return new NullIterator();
         }
    }

The NullIterator class simply returns **false** when ``valid()`` is called.

.. code-block:: php

    <?php
    class NullIterator implements Iterator {
    
      public function __construct()
      {
      }
    
      public function current() { return null; }
      public function key() { return null; }
      public function next() {  }
      public function rewind() {  }
      public function valid() { return false; } 
    }
    ?>

The MenuItem class looks like this

.. code-block:: php

    <?php
    class MenuItem extends MenuComponent {
    
        private $name;
        private $description;
        private $vegetarian;
        private $price;
    
        public function __construct($name, $description, $vegetarian, $price) 
        { 
              $this->name = $name;
              $this->description = $description;
              $this->vegetarian = $vegetarian;
              $this->price = $price;
        }
    
        public function getName() 
        {
              return $this->name;
        }
    
        public function getDescription()
        {
              return $this->description;
        }
    
        public function getPrice() 
        {
              return $this->price;
        }
    
        public function isVegetarian() 
        {
              return $this->vegetarian;
        }
    
        public function __toString() 
        {
              $str = "<br />  " . $this->getName();
    
              if ($this->isVegetarian()) {
    
                  $str .= "(v)";
              }
    
              $str .=  ", " . $this->getPrice();
              $str .= "     -- " . $this->getDescription();
              
              return $str;
        }
    }

Finally, Menu looks like this

.. code-block:: php

    <?php
    
    class Menu extends MenuComponent implements IteratorAggregate {
    
       private $menuComponents;
       private $name;
       private $description;
       
       public function __construct($name, $description) 
       {
           $this->description = $description;
           $this->name = $name;
           $this->menuComponents = array();
       }
    
       public function add(MenuComponent $menuComponent)
       {
           $this->menuComponents[spl_object_hash($menuComponent)] = $menuComponent;
       }
    
       public function remove(MenuComponent $menuComponent) 
       {
           unset($this->menuComponents[\spl_object_hash($menuComponent)]);
       }
    
       public function getIterator() // ?
       {
           echo "Menu::getIterator() just called\n";
           return new MenuIterator($this->menuComponents); 
       }
    
       public function getName() { return $this->name; }

       public function getDescription() { return $this->description; }
    
       public function __toString() 
       {
           $str ="<br />\n" . $this->getName();
           $str .= ", " . $this->getDescription();
           $str .= "<br />\n---------------------";
     
           foreach ($this->menuComponents as $component) {   
    
            $str .= $component; // calls component's __toString()
           } 
           $str .= "<br />\n";
           return $str;
      }
    }
    
and MenuIterator looks like this

.. code-block:: php

    <?php
    class MenuIterator implements Iterator {
    
      private $iter;
    
      public function __construct(&$m)
      {
         $this->iter = new ArrayIterator($m); 
      }
    
      public function current() { $this->iter->current(); }
      public function key() { $this->iter->key(); }
      public function next() { $this->iter->next(); }
      public function rewind() { $this->iter->rewind(); }
      public function valid() {  $this->iter->valid(); }
    }
        
Finally, The test code looks like this

.. code-block:: php

    <?php
    include "SplClassLoader.php";
    
    $loader = new SplClassLoader();
    $loader->register();
    
    try {
        
        $pancakeHouseMenu = new Menu("PANCAKE HOUSE MENU", "Breakfast");
        
        $dinerMenu = new Menu("DINER MENU", "Lunch");
        
        $cafeMenu = new Menu("CAFE MENU", "Dinner");
    
        $dessertMenu = new Menu("DESSERT MENU", "Dessert of course!");
    
        $coffeeMenu = new Menu("COFFEE MENU", "Stuff to go with your afternoon coffee");
        
        $allMenus = new Menu("ALL MENUS", "All menus combined");
        
        $allMenus->add($pancakeHouseMenu);
        $allMenus->add($dinerMenu);
        $allMenus->add($cafeMenu);
        
        $pancakeItem = new MenuItem(
                "K&B's Pancake Breakfast", 
                "Pancakes with scrambled eggs, and toast", 
                true,
                2.99);
        
        $pancakeHouseMenu->add($pancakeItem);
        
        $pancakeHouseMenu->add(new MenuItem(
                "Regular Pancake Breakfast", 
                "Pancakes with fried eggs, sausage", 
                false,
                2.99));
        
        $pancakeHouseMenu->add(new MenuItem(
                "Blueberry Pancakes",
                "Pancakes made with fresh blueberries, and blueberry syrup",
                true,
                3.49));
        
        $pancakeHouseMenu->add(new MenuItem(
                "Waffles",
                "Waffles, with your choice of blueberries or strawberries",
                true,
                3.59));
        
        $dinerMenu->add(new MenuItem(
                "Vegetarian BLT",
                "(Fakin') Bacon with lettuce & tomato on whole wheat", 
                true, 
                2.99));
        $dinerMenu->add(new MenuItem(
                "BLT",
                "Bacon with lettuce & tomato on whole wheat", 
                false, 
                2.99));
        
        $dinerMenu->add(new MenuItem(
                "Soup of the day",
                "A bowl of the soup of the day, with a side of potato salad", 
                false, 
                3.29));
        
        $dinerMenu->add(new MenuItem(
                "Hotdog",
                "A hot dog, with saurkraut, relish, onions, topped with cheese",
                false, 
                3.05));
        $dinerMenu->add(new MenuItem(
                "Steamed Veggies and Brown Rice",
                "Steamed vegetables over brown rice", 
                true, 
                3.99));
        
        $dinerMenu->add(new MenuItem(
                "Pasta",
                "Spaghetti with Marinara Sauce, and a slice of sourdough bread",
                true, 
                3.89));
        
        $dinerMenu->add($dessertMenu);
        
        $dessertMenu->add(new MenuItem(
                "Apple Pie",
                "Apple pie with a flakey crust, topped with vanilla icecream",
                true,
                1.59));
        
        $dessertMenu->add(new MenuItem(
                "Cheesecake",
                "Creamy New York cheesecake, with a chocolate graham crust",
                true,
                1.99));
        
        $dessertMenu->add(new MenuItem(
                "Sorbet",
                "A scoop of raspberry and a scoop of lime",
                true,
                1.89));
        
        $cafeMenu->add(new MenuItem(
                "Veggie Burger and Air Fries",
                "Veggie burger on a whole wheat bun, lettuce, tomato, and fries",
                true, 
                3.99));
        
        $cafeMenu->add(new MenuItem(
                "Soup of the day",
                "A cup of the soup of the day, with a side salad",
                false, 
                3.69));
    
        $cafeMenu->add(new MenuItem(
                "Burrito",
                "A large burrito, with whole pinto beans, salsa, guacamole",
                true, 
                4.29));
        
        $cafeMenu->add($coffeeMenu);
        
        $coffeeMenu->add(new MenuItem(
                "Coffee Cake",
                "Crumbly cake topped with cinnamon and walnuts",
                true,
            1.59));
        
        $coffeeMenu->add(new MenuItem(
                "Bagel",
                "Flavors include sesame, poppyseed, cinnamon raisin, pumpkin",
                false,
                0.69));
        
        $coffeeMenu->add(new MenuItem(
                "Biscotti",
                "Three almond or hazelnut biscotti cookies",
                true,
                0.89));
        
        echo $allMenus; // calls Menu::__toString()
        echo "\n===================\n";
        $iter = $allMenus->getIterator();
        $d = 10;
        
    } catch (Exception $ex) {
        
       echo "Exception on line " . $ex->getLine() . " of file " . $ex->getFile() ."\n";
       echo $ex->getMessage();
    }

Generator functions 
^^^^^^^^^^^^^^^^^^^

A generator is a function that can be iterated by ``foreach``. It differs from a regular function because it has a **yield** statement instead of **return** statement. 
To understand how to create a generator, first imagine class that returns Fibonacci numbers when its is iterated:

.. code-block:: php

    <?php
    class GenerateFibonacci implements Iterator {
       
       private $f1;
       private $f2;
       private $key;
    
       public function __construct() 
       { 
          rewind(); 
       }
    
       public function rewind()
       {
          $this->key = $this->f0 = 0;
          $this->f1 = 1;
       }
    
       public function valid()
       {
          return true;// increases without bound.  
       }
    
       public function current()
       {
         return $this->f1 + $this->f0;
       }
       
       public function next()
       {
          $temp = $this->current;
          $this->f0 = $this->f1;	
          $this->f1 = $temp;
          $this->key++;
       }    
    
       public function key() 
       {
          return $this->key;
       } 
    }
    
    $fibonacci = new FibonacciGenerator();
    
    ``foreach``($fibonacci => $fib_number) {
    
      echo $fib_number . ", ";
    }

A Fibonacci generator function is much simpler to implement:

.. code-block:: php

    <?php
    function fibonacci()
    {
      $f0 = 0;
      $f1 = 1;
    
      while ($true) {
    
        $current = $f1 + $f0;
        $f0 = $f1;
        $f1 = $current;
    
        yield $current;
    } 

    ``foreach``(fibonacci() => $fib_number) {
    
      echo $fib_number . ", ";
    }

SeekableIterator interface
^^^^^^^^^^^^^^^^^^^^^^^^^^

SeekableIterator iterface extends Iterator and adds the ``seek($position)``, to allow repositioning of the iterator (to anywhere within its start position to one past
its end position).

ArrayAccess interface
^^^^^^^^^^^^^^^^^^^^^

``ArrayAccess`` interface allows random access to your collection through the array operator []:

.. code-block:: java

   ArrayAccess { 
        /* Methods */
        abstract public boolean offsetExists ( mixed $offset )
        abstract public mixed offsetGet ( mixed $offset )
        abstract public void offsetSet ( mixed $offset , mixed $value )
        abstract public void offsetUnset ( mixed $offset )
   }

Example of Book class that implements ArrayAccess

.. code-block:: php

    <?php
    class Book implements ArrayAccess {
        public $title;

        public $author;

        public $isbn;

        public function offsetExists( $offset )
        {
            return isset( $this->$offset );
        }

        public function offsetSet( $offset, $value)
        {
            $this->$offset = $value;
        }

        public function offsetGet( $offset )
        {
            return $this->$offset;
        }

        public function offsetUnset( $offset )
        {
            unset( $this->$offset );
        }
    } /*** end of class ***/

    $book = new book;

    $book['title']= 'Pro PHP';
    $book['author'] = 'Kevin McArthur';
    $book['isbn'] = 1590598199;

    foreach($book as $key => $value) {
        echo "<p>book[$key] = $value</p>\n";
    }

Note: In PHP any class can be used in a ``foreach`` loop. It does not have to implement the Iterator interface(or one that extends it). By default the properties
of the object are returned by default.

Countable interface
^^^^^^^^^^^^^^^^^^^

Implementing the ``Countable`` interface and providing a ``count()`` method allows your objects to be passed to ``\count($collection);``.

ArrayObject class
^^^^^^^^^^^^^^^^^

ArrayObject implements IteratorAggregate , ArrayAccess , Serializable , and Countable. It also implements a number of its own member functions:

.. code-block:: java

    ArrayObject implements IteratorAggregate , ArrayAccess , Serializable , Countable {

        /* Constants */
        const integer STD_PROP_LIST = 1 ;
        const integer ARRAY_AS_PROPS = 2 ;
        /* Methods */
        public __construct ([ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator" ]]] )
 
        // ArrayAccess methods
        public bool offsetExists ( mixed $index )
        public mixed offsetGet ( mixed $index )
        public void offsetSet ( mixed $index , mixed $newval )
        public void offsetUnset ( mixed $index )

        // IteratorAggregate methods  
        public ArrayIterator getIterator ( void )

        // Serializable methods
        public void unserialize ( string $serialized )
        public string serialize ( void )

        // Countable method
        public int count ( void )

        // other public methods
        public void append ( mixed $value )
        public void asort ( void )
        public array exchangeArray ( mixed $input )
        public array getArrayCopy ( void )
        public int getFlags ( void )
        public string getIteratorClass ( void )
        public void ksort ( void )
        public void natcasesort ( void )
        public void natsort ( void )
        public void uasort ( callable $cmp_function )
        public void uksort ( callable $cmp_function )

        public void setFlags ( int $flags )

        public void setIteratorClass ( string $iterator_class )
    }    
    
ArrayObject::getIterator() will return an ArrayIterator. If you extend ArrayObject, you can return your own iterator type, but it must derive from ArrayIterator.

Usage
~~~~~

ArrayObject lets you treat an object like an array: it allows you to access its access properties using array syntax, and it allows iterating them via foreach. When you
create an ArrayObject from an associative array, the objects properties take on the name of the keys of the array.

.. code-block:: php
  
    <?php
    data = array(
        "name"  => "John Doe",
        "email" => "john@domain.com"
    );
    
    $arrayObj = new ArrayObject($data);
    // access the object properties using an array notation
    echo "Name is " . $arrayObj["name"] . ". Email is " . $arrayObj["email"];

You can also pass an object to the constructor, and it will create properties identical to the names of the properties of the object\ |mdash|\ provided they are public.

.. code-block:: php

    <?php
    class EmailUser { 
         public $name; 
         public $email;
         public function __construct($name, $email) { $this->name = $name; $this->email = $email; }
    }    
    
    $user = new EmailUser("John Doe", "john@domain.com");
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($user);
    
    // access the object properties using an array notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo "Full name: " . $arrayObj['name'] . " Email: " . $arrayObj['email'];

    // count the number of properties in the object
    echo "total properties is " . count($arrayObj);

``new ArrayObject($data)`` is equivalent to ``new ArrayObject($data, ArrayObject::STD_PROP_LIST)``. ``STD_PROP_LIST`` is the default behavior.
A good way to understand the usefulness ArrayObject is to compare it to the SimpleXML extension. SimpleXML objects are a type of ArrayObject in that a SimpleXML object 
also acts like an array which makes it efficient to use because you can just **foreach** or access one of the elements within the list. You don not
have to grab an array from the object and then iterate over and do something else with it if you want the tag name or an attribute.

When the constant ``ArrayObject::ARRAY_AS_PROPS`` is passed to the constructor or to the ``setFlags()`` method, itâ€™s possible to handle the properties by means of an
object syntax. For example

.. code-block:: php

    $data = array(
        â€˜nameâ€™  => â€˜John Doeâ€™,
        â€˜emailâ€™ => â€˜john@domain.comâ€™
    );
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($data, ArrayObject::ARRAY_AS_PROPS);
    
    // access the object properties using an object notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo â€˜Full name: â€˜ . $arrayObj->name . â€˜ Email: â€˜ . $arrayObj->email;
    
    // count the number of properties in the object
    echo â€˜Number of properties assigned to the object: â€˜ . count($arrayObj);

ArrayIterator class
^^^^^^^^^^^^^^^^^^^

.. code-block:: java

    class ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...  }

This iterator allows you to both unset and modify values and keys while iterating over arrays and objects. To explictily create an ArrayIterator, pass a PHP array() to the constructor.
Explicitly calling ``ArrayObject::getIterator()`` also returns an ArrayIterator.  ArrayIterator instances are created implicitly when **``foreach``** encounters an ArrayObject.

ArrayIterator wraps these PHP functions for built\ |ndash|\ in PHP arrays: ksort, natcasesort, natsort, uasort, and uksort.

.. code-block:: java

    ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...}
        //. . . snip
        public function asort ( void );
        public function ksort ( void );
        public function natcasesort ( void );
        public function natsort ( void );
        public function uasort ( string $cmp_function );
        public function uksort ( string $cmp_function );
    } 
       
You instantiate ArrayIterator either explicitly by passing a built-in array or implicitly by invoking ``foreach`` on an ArrayObject, which invokes ``ArrayObject::getIterator()``, which
returns an ArrayIterator.

Iterating Recursive Structures
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

How do we iterate a multidimensional array, or any array with a nested subarray? And more generally how do we create iterators for composite objects that model containment hierachies?
For example, if we call foreach on this array 

.. code-block:: php

    <?php
    $arr = array(0, 
            1 => array(10, 20, 30), 
            2,
            3 => array(1, 2, 3)
            );

    foreach($arr as $key => $value) {
        
        echo "$key => $value \n";
    }
    
we will get an error when the first subarrays is encountered.

RecursiveIterator
~~~~~~~~~~~~~~~~~

The first interface used to solve the problem of iterating any array that has at least one subarray is RecursiveIterator.
It extends Iterator and adds the ``hasChildren()`` and ``getChildren()``. ``hasChildren`` returns **true** if the current element can be iterated, and ``getChildren()`` 
returns that iterator ``getChildren()``, which must at least be of type RecursiveIterator.

Here is an sample implementation of ``RecursiveIterator``. It extends ``arrayIterator`` implemented :ref:`previously <arrayIterator>`. 

.. code-block:: php

    <?php
     class MyRecursiveIterator extends arrayIterator implements RecursiveIterator {
        
        public function __construct(array &$a) 
        {
            parent::__construct($a);
        }
      
        // Returns true if an iterator can be created/returned for the current entry.
        public function hasChildren() 
        {
            return is_array(current($this->a));
        }
       
        // Returns a MyRecursiveIterator for the current entry.
        public function getChildren() 
        {
            $subarray = current($this->a);
            return new MyRecursiveIterator($subarray);
        }
    }

To use ``MyRecursiveIterator`` you write a recursive function:

.. code-block:: php

    <?php
    function recursive_iterate(MyRecursiveIterator $it)
    {
      while ($it->valid()) {

        // if there is a subarray, we call getChildren and recurse...  
        if ($it->hasChildren()) {
            
           echo $it->key(). " => (" ;
           
           recursive_iterate($it->getChildren());
           
           echo "), ";

        } else {
       
          // otherwise, print the currentkey and value.
          echo $it->key() . " => " . $it->current() . ", ";
        }
    
        $it->next();
      }
    }

Finally, we create an array with some subarrays and use our new code:   

.. code-block:: php

    <?php
    $a2 = array(0, 1, 
                2 => array(10, 20, 30), 
                3, 4, 
                5 => array(1, 2, 3));
    
    echo "\n=============\n";
    
    $mri = new MyRecursiveIterator($a2);
    
    recursive_iterate($mri);

This outputs:

.. code-block:: bash

    0 => 0, 1 => 1, 2 => (0 => 10, 1 => 20, 2 => 30, ), 3 => 3, 4 => 4, 5 => (0 => 1, 1 => 2, 2 => 3, ), 

RecursiveIteratorIterator
~~~~~~~~~~~~~~~~~~~~~~~~~

Fortunately, PHP already provides support for recursive iteration of multi-dimensional arrays. We do not have to roll our own. You can iterate any array with subarrays 
in a ``foreach`` loop using ``RecursiveIteratorIterator`` whose constructor, takes a ``RecursiveIterator`` instance. Example:

.. code-block:: php

    <?php 
    $it = new RecursiveIteratorIterator(new MyRecusvieIterator($a2)) {
    foreach($it as $value)

          // print the value.
          echo $it->current() . ", ";
    }

If we change ``foreach`` to return both the current key and value, like so

.. code-block:: php
 
    <?php 
    $it = new RecursiveIteratorIterator(new MyRecusvieIterator($a2)) {
    foreach($it as $value)

          // print the curren tkey and value.
         echo $it->key() . " => " . $it->current() . ", ";
    }

the output is

.. code-block:: bash

    0 => 0, 1 => 1, 0 => 10, 1 => 20, 2 => 30, 3 => 3, 4 => 4, 0 => 1, 1 => 2, 2 => 3, 

which does not includes key values for the subarrays: the keys 2 and 5 in the outer array are never returned.

....finish these idea by using this bookmark:

Incorporate this info:
as well as     

* http://www.giorgiosironi.com/2010/02/practical-php-patterns-iterator.html   Very good overview
* http://stackoverflow.com/questions/12077177/how-does-recursiveiteratoriterator-work-in-php The examples here are really educational. They illustrares the differences between the iterator types.
* http://www.sitepoint.com/using-spl-iterators-1/   Gentle Introduction
* https://learnable.com/books/php-master-write-cutting-edge-code/online/apbs03.html
* http://coder-zone.blogspot.com/2013/05/custom-recursiveiterator.html

and  this `excellent discussion <http://students.kiv.zcu.cz/doc/php5/~helly/php/ext/spl/main.html>`_ on iterators in PHP, which explains the use of RecursiveIteratorIterator::SELF_FIRST.

Based on first link above, RecursiveIteratorIterator adapts a RecursiveIterator, so that it can be used like a Iterator and used in ``foreach`` to recurse an entire tree structure. Technically, RecursiveIterator is an OuterIterface, but the intent 
is still the same: allow Iterator\ |ndash|\ like use in ``foreach``. 

RecursiveArrayIterator
~~~~~~~~~~~~~~~~~~~~~~

RecursiveArrayIterator adds two methods to ArrayIterator: ``getChildren()`` and ``hasChildren()``.

.. code-block:: java

    RecursiveArrayIterator extends ArrayIterator implements RecursiveIterator {

        /* Methods */
        /* Returns an iterator for the current entry if it is an array or object */
        public RecursiveArrayIterator getChildren ( void );

        /* Returns true if the current entry is an array or object */
        public bool hasChildren ( void );

        /* Inherits */
        public void ArrayIterator::append ( mixed $value );
        public void ArrayIterator::asort ( void );
        public ArrayIterator::__construct ([ mixed $array = array(); [, int $flags = 0 ]] );
        public int ArrayIterator::count ( void );
        public mixed ArrayIterator::current ( void );
        public array ArrayIterator::getArrayCopy ( void );
        public void ArrayIterator::getFlags ( void );
        public mixed ArrayIterator::key ( void );
        public void ArrayIterator::ksort ( void );
        public void ArrayIterator::natcasesort ( void );
        public void ArrayIterator::natsort ( void );
        public void ArrayIterator::next ( void );
        public void ArrayIterator::offsetExists ( string $index );
        public mixed ArrayIterator::offsetGet ( string $index );
        public void ArrayIterator::offsetSet ( string $index , string $newval );
        public void ArrayIterator::offsetUnset ( string $index );
        public void ArrayIterator::rewind ( void );
        public void ArrayIterator::seek ( int $position );
        public string ArrayIterator::serialize ( void );
        public void ArrayIterator::setFlags ( string $flags );
        public void ArrayIterator::uasort ( string $cmp_function );
        public void ArrayIterator::uksort ( string $cmp_function );
        public string ArrayIterator::unserialize ( string $serialized );
        public bool ArrayIterator::valid ( void );
    }

This iterator allows you to unset and modify values and keys while iterating over Arrays and Objects in the same way as the ArrayIterator. Additionally it is possible to iterate over the current iterator entry.
The use of ArrayIterator is straight forward, but limited to single dimensional arrays. Sometimes youâ€™ll have a multidimensional array and youâ€™ll want to iterate through the nested arrays recursively. In this case you can use RecursiveArrayIterator
See this `article <http://www.sitepoint.com/using-spl-iterators-1/>`_ for next topic.

What did the verbage above mean?


