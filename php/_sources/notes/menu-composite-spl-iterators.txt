.. include:: <isopub.txt>

.. role:: kurt-code

Standard PHP Library
====================

Iterators 
---------

Iterator interface
^^^^^^^^^^^^^^^^^^

The ``Iterator`` interface allows an object to be used in ``foreach`` loops. 

.. code-block:: java

    interface Iterator { // conceptual definitions
        public function mixed current ( void );
        public function scalar key ( void );
        public function void next ( void );
        public function void rewind ( void );
        public function boolean valid ( void );
    }
    
    class MyContainer implements Iterator {
       //...snip 
    }

     $x = new MyClass(); // implements Iterator
     //...add some elements
     // iterate using ``foreach``
     foreach($x as $element) {

         echo $element . "\n"; 
     }    

The code below demonstates the order of Iterator method calls that happened in the ``foreach`` loop above.

.. code-block:: php

    <?php
     for ( $x->rewind(); $x->valid() ; $x->next() ) {

        $element =  $x->current(); 
        echo $element; 
     }    

iterator_apply( $it, 'callback', array($it) ) 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Applies a callback to an objects that implements ``Iterator``:

.. code-block:: php

    <?php    
    function print_caps(Iterator $iterator) {
        echo strtoupper($iterator->current()) . "\n";
        return TRUE;
    }
    
    $it = new ArrayIterator(array("Apples", "Bananas", "Cherries"));
    iterator_apply($it, "print_caps", array($it));

IteratorAggregate interface
^^^^^^^^^^^^^^^^^^^^^^^^^^^

``IteratorAggregate`` lets you implement your iterator externally.

.. code-block:: java

    class MyContainer implements IteratorAggregate {
       public function getIterator() { return new MyExternalIterator($this); }
    }

    class MyExternalIterator implements Iterator {
     //...snip
        public function __construct(MyContainer $member)
        {
          // Store $member locally for iteration
        }
    
        // Implementations for: current(), key(), next(), rewind() and valid() to iterate over data in $member
    }

``foreach`` implicitly calls **getIterator()** 

.. code-block:: php

    <?php
     $x = new SomeClass(); // implements IteratorAggregate
     //...add some elements
     // iterate using ``foreach``
     ``foreach`` ($x as $element) { // calls SomeClass::getIterator()

         echo $element . "\n"; 
     }    

The example below is of an instance of the composite pattern. **Menu** is the composite class that implements **IteratorAggregate** to return an iterator.
The ``Menu::__toString()`` method invokes ``foreach`` on its components\ |mdash|\ either submenus or menu items\ |mdash|\ like so

.. code-block:: php

    <?php

        ``foreach`` ($this->menuComponents as $component) {   

   	    $str .= $component; // calls component's __toString()
        } 
    
Class **MenuComponent** is the abstract base class for all menus and menu items:

.. code-block:: php

    <?php
    abstract class MenuComponent {
    
         public function add(MenuComponent  $m)
         {
             throw new \Exception("method MenuComponent::add not implemented");
         }
         public function remove(MenuComponent $m)
         {
             throw new \Exception("method MenuComponent::remove not implemented");
         }
         public function getName()
         {
             throw new \Exception("method MenuComponent::getName not implemented");
         }
         public function getDescription()
         {
             throw new \Exception("method MenuComponent::getDescription  not implemented");
         }
         public function getPrice()
         {
             throw new \Exception("method MenuComponent::getPrice not implemented");
         }
         public function isVegetarian()
         {
             throw new \Exception("method MenuComponent::isVegetarian not implemented");
         }
    }

**MenuItem** implents ``__toString()``

.. code-block:: php

    <?php
    class MenuItem extends MenuComponent {
    
        private $name;
        private $description;
        private $vegetarian;
        private $price;
    
        public function __construct($name, $description, $vegetarian, $price) 
        { 
              $this->name = $name;
              $this->description = $description;
              $this->vegetarian = $vegetarian;
              $this->price = $price;
        }
    
        public function getName() 
        {
              return $this->name;
        }
    
        public function getDescription()
        {
              return $this->description;
        }
    
        public function getPrice() 
        {
              return $this->price;
        }
    
        public function isVegetarian() 
        {
              return $this->vegetarian;
        }
    
        public function __toString() 
        {
              $str = "<br />  " . $this->getName();
    
              if ($this->isVegetarian()) {
    
   	          $str .= "(v)";
              }
    
              $str .=  ", " . $this->getPrice();
              $str .= "     -- " . $this->getDescription();
              
              return $str;
        }
    }

Menu implements ``__toString()``, and the ``foreach`` loop in ``__toString()`` implicitly calls the ``getIterator()`` method.

.. code-block:: php

    <?php
    class Menu extends MenuComponent implements IteratorAggregate {

       private $menuComponents;
       private $name;
       private $description;
       
       public function __construct($name, $description) 
       { 
      	   $this->description = $description;
           $this->name = $name;
           $this->menuComponents = new ArrayObject();// TODO: change to array()
       }

       public function add(MenuComponent $menuComponent)
       {
           $this->menuComponents[spl_object_hash($menuComponent)] = $menuComponent;
       }

       public function remove(MenuComponent $menuComponent) 
       {
           unset($this->menuComponents[\spl_object_hash($menuComponent)]);
       }

       public function getIterator()
       {
           echo "Menu::getIterator() just called\n";
           return $this->menuComponents->getIterator();
       }

       public function getName() { return $this->name; }

       public function getDescription() { return $this->description; }

       public function __toString() 
       {
           $str ="<br />\n" . $this->getName();
           $str .= ", " . $this->getDescription();
           $str .= "<br />\n---------------------";
     
           ``foreach`` ($this->menuComponents as $component) {   

   	    $str .= $component; // calls component's __toString()
           } 
           $str .= "<br />\n";
           return $str;
      }
    }
    
    include "SplClassLoader.php";
    
    $loader = new SplClassLoader();
    $loader->register();
    
    try {
        
        $pancakeHouseMenu = new Menu("PANCAKE HOUSE MENU", "Breakfast");
    
        $dinerMenu = new Menu("DINER MENU", "Lunch");
    
        $cafeMenu = new Menu("CAFE MENU", "Dinner");
    
        $dessertMenu = new Menu("DESSERT MENU", "Dessert of course!");
    
        $coffeeMenu = new Menu("COFFEE MENU", "Stuff to go with your afternoon coffee");
        
        $allMenus = new Menu("ALL MENUS", "All menus combined");
        
        $allMenus->add($pancakeHouseMenu);
        $allMenus->add($dinerMenu);
        $allMenus->add($cafeMenu);
        
        $pancakeHouseMenu->add(new MenuItem(
	        "K&B's Pancake Breakfast", 
	        "Pancakes with scrambled eggs, and toast", 
	        true,
	        2.99));
        
        $pancakeHouseMenu->add(new MenuItem(
	        "Regular Pancake Breakfast", 
	        "Pancakes with fried eggs, sausage", 
	        false,
	        2.99));
        
        $pancakeHouseMenu->add(new MenuItem(
	        "Blueberry Pancakes",
	        "Pancakes made with fresh blueberries, and blueberry syrup",
	        true,
	        3.49));
        
        $pancakeHouseMenu->add(new MenuItem(
	        "Waffles",
	        "Waffles, with your choice of blueberries or strawberries",
	        true,
	        3.59));
        
        $dinerMenu->add(new MenuItem(
	        "Vegetarian BLT",
	        "(Fakin') Bacon with lettuce & tomato on whole wheat", 
	        true, 
	        2.99));
        $dinerMenu->add(new MenuItem(
	        "BLT",
	        "Bacon with lettuce & tomato on whole wheat", 
	        false, 
	        2.99));
        
        $dinerMenu->add(new MenuItem(
	        "Soup of the day",
	        "A bowl of the soup of the day, with a side of potato salad", 
	        false, 
	        3.29));
        
        $dinerMenu->add(new MenuItem(
	        "Hotdog",
	        "A hot dog, with saurkraut, relish, onions, topped with cheese",
	        false, 
	        3.05));
        $dinerMenu->add(new MenuItem(
	        "Steamed Veggies and Brown Rice",
	        "Steamed vegetables over brown rice", 
	        true, 
	        3.99));
        
        $dinerMenu->add(new MenuItem(
	        "Pasta",
	        "Spaghetti with Marinara Sauce, and a slice of sourdough bread",
	        true, 
	        3.89));
        
        $dinerMenu->add($dessertMenu);
        
        $dessertMenu->add(new MenuItem(
	        "Apple Pie",
	        "Apple pie with a flakey crust, topped with vanilla icecream",
	        true,
	        1.59));
        
        $dessertMenu->add(new MenuItem(
	        "Cheesecake",
	        "Creamy New York cheesecake, with a chocolate graham crust",
	        true,
	        1.99));
        
        $dessertMenu->add(new MenuItem(
	        "Sorbet",
	        "A scoop of raspberry and a scoop of lime",
	        true,
	        1.89));
        
        $cafeMenu->add(new MenuItem(
	        "Veggie Burger and Air Fries",
	        "Veggie burger on a whole wheat bun, lettuce, tomato, and fries",
	        true, 
	        3.99));
        
        $cafeMenu->add(new MenuItem(
	        "Soup of the day",
	        "A cup of the soup of the day, with a side salad",
	        false, 
	        3.69));
    
        $cafeMenu->add(new MenuItem(
	        "Burrito",
	        "A large burrito, with whole pinto beans, salsa, guacamole",
	        true, 
	        4.29));
        
        $cafeMenu->add($coffeeMenu);
        
        $coffeeMenu->add(new MenuItem(
	        "Coffee Cake",
	        "Crumbly cake topped with cinnamon and walnuts",
	        true,
	    1.59));
        
        $coffeeMenu->add(new MenuItem(
	        "Bagel",
	        "Flavors include sesame, poppyseed, cinnamon raisin, pumpkin",
	        false,
	        0.69));
        
        $coffeeMenu->add(new MenuItem(
	        "Biscotti",
	        "Three almond or hazelnut biscotti cookies",
	        true,
	        0.89));
        
        echo $allMenus; // calls Menu::__toString()
        
    } catch (Exception $ex) {
        
       echo "Exception on line " . $ex->getLine() . " of file " . $ex->getFile() ."\n";
       echo $ex->getMessage();
    }

Generator functions 
^^^^^^^^^^^^^^^^^^^

A generator is a function that can be iterated by ``foreach``. It differs from a regular function because it has a **yield** statement instead of **return** statement. 
To understand how to create a generator, first imagine class that returns Fibonacci numbers when its is iterated:

.. code-block:: php

    <?php
    class GenerateFibonacci implements Iterator {
       
       private $f1;
       private $f2;
       private $key;
    
       public function __construct() 
       { 
          rewind(); 
       }
    
       public function rewind()
       {
          $this->key = $this->f0 = 0;
          $this->f1 = 1;
       }
    
       public function valid()
       {
          return true;// increases without bound.  
       }
    
       public function current()
       {
         return $this->f1 + $this->f0;
       }
       
       public function next()
       {
          $temp = $this->current;
          $this->f0 = $this->f1;	
          $this->f1 = $temp;
          $this->key++;
       }    
    
       public function key() 
       {
          return $this->key;
       } 
    }
    
    $fibonacci = new FibonacciGenerator();
    
    ``foreach``($fibonacci => $fib_number) {
    
      echo $fib_number . ", ";
    }

A Fibonacci generator function is much simpler to implement:

.. code-block:: php

    <?php
    function fibonacci()
    {
      $f0 = 0;
      $f1 = 1;
    
      while ($true) {
    
        $current = $f1 + $f0;
        $f0 = $f1;
        $f1 = $current;
    
        yield $current;
    } 

    ``foreach``(fibonacci() => $fib_number) {
    
      echo $fib_number . ", ";
    }

SeekableIterator interface
^^^^^^^^^^^^^^^^^^^^^^^^^^

SeekableIterator iterface extends Iterator and adds the ``seek($position)``, to allow repositioning of the iterator (to anywhere within its start position to one past
its end position).

ArrayAccess interface
^^^^^^^^^^^^^^^^^^^^^

``ArrayAccess`` interface allows random access to your collection through the array operator []:

.. code-block:: java

   ArrayAccess { 
        /* Methods */
        abstract public boolean offsetExists ( mixed $offset )
        abstract public mixed offsetGet ( mixed $offset )
        abstract public void offsetSet ( mixed $offset , mixed $value )
        abstract public void offsetUnset ( mixed $offset )
   }

Example of Book class that implements ArrayAccess

.. code-block:: php

    <?php
    class Book implements ArrayAccess {
        public $title;

        public $author;

        public $isbn;

        public function offsetExists( $offset )
        {
            return isset( $this->$offset );
        }

        public function offsetSet( $offset, $value)
        {
            $this->$offset = $value;
        }

        public function offsetGet( $offset )
        {
            return $this->$offset;
        }

        public function offsetUnset( $offset )
        {
            unset( $this->$offset );
        }
    } /*** end of class ***/

    $book = new book;

    $book['title']= 'Pro PHP';
    $book['author'] = 'Kevin McArthur';
    $book['isbn'] = 1590598199;

    foreach($book as $key => $value) {
        echo "<p>book[$key] = $value</p>\n";
    }

Note: In PHP any class can be used in a ``foreach`` loop. It does not have to implement the Iterator interface(or one that extends it). By default the properties
of the object are returned by default.

Countable interface
^^^^^^^^^^^^^^^^^^^

Implementing the ``Countable`` interface and providing a ``count()`` method allows your objects to be passed to ``\count($collection);``.

ArrayObject class
^^^^^^^^^^^^^^^^^

ArrayObject implements IteratorAggregate , ArrayAccess , Serializable , and Countable. It also implements a number of its own member functions:

.. code-block:: java

    ArrayObject implements IteratorAggregate , ArrayAccess , Serializable , Countable {

        /* Constants */
        const integer STD_PROP_LIST = 1 ;
        const integer ARRAY_AS_PROPS = 2 ;
        /* Methods */
        public __construct ([ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator" ]]] )
 
        // ArrayAccess methods
        public bool offsetExists ( mixed $index )
        public mixed offsetGet ( mixed $index )
        public void offsetSet ( mixed $index , mixed $newval )
        public void offsetUnset ( mixed $index )

        // IteratorAggregate methods  
        public ArrayIterator getIterator ( void )

        // Serializable methods
        public void unserialize ( string $serialized )
        public string serialize ( void )

        // Countable method
        public int count ( void )

        // other public methods
        public void append ( mixed $value )
        public void asort ( void )
        public array exchangeArray ( mixed $input )
        public array getArrayCopy ( void )
        public int getFlags ( void )
        public string getIteratorClass ( void )
        public void ksort ( void )
        public void natcasesort ( void )
        public void natsort ( void )
        public void uasort ( callable $cmp_function )
        public void uksort ( callable $cmp_function )

        public void setFlags ( int $flags )

        public void setIteratorClass ( string $iterator_class )
    }    
    
ArrayObject::getIterator() will return an ArrayIterator. If desired, you can return your own iterator type\ |mdash|\ which must derive from ArrayIterator.

Usage
~~~~~

ArrayObject lets you treat an object like an array: it allows you to access its access properties using array syntax, and it allows iterating them via foreach. When you
create an ArrayObject from an associative array, the objects properties take on the name of the keys of the array.

.. code-block:: php
  
    <?php
    data = array(
        "name"  => "John Doe",
        "email" => "john@domain.com"
    );
    
    $arrayObj = new ArrayObject($data);
    // access the object properties using an array notation
    echo "Name is " . $arrayObj["name"] . ". Email is " . $arrayObj["email"];

You can also pass an object to the constructor, and it will create properties identical to the names of the properties of the object\ |mdash|\ provided they are public.

.. code-block:: php

    <?php
    class EmailUser { 
         public $name; 
         public $email;
         public function __construct($name, $email) { $this->name = $name; $this->email = $email; }
    }    
    
    $user = new EmailUser("John Doe", "john@domain.com");
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($user);
    
    // access the object properties using an array notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo "Full name: " . $arrayObj['name'] . " Email: " . $arrayObj['email'];

    // count the number of properties in the object
    echo "total properties is " . count($arrayObj);

``new ArrayObject($data)`` is equivalent to ``new ArrayObject($data, ArrayObject::STD_PROP_LIST)``. ``STD_PROP_LIST`` is the default behavior.
A good way to understand the usefulness ArrayObject is to compare it to the SimpleXML extension. SimpleXML objects are a type of ArrayObject in that a SimpleXML object 
also acts like an array which makes it efficient to use because you can just **foreach** or access one of the elements within the list. You don not
have to grab an array from the object and then iterate over and do something else with it if you want the tag name or an attribute.

When the constant ``ArrayObject::ARRAY_AS_PROPS`` is passed to the constructor or to the ``setFlags()`` method, it’s possible to handle the properties by means of an
object syntax. For example

.. code-block:: php

    $data = array(
        ‘name’  => ‘John Doe’,
        ‘email’ => ‘john@domain.com’
    );
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($data, ArrayObject::ARRAY_AS_PROPS);
    
    // access the object properties using an object notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo ‘Full name: ‘ . $arrayObj->name . ‘ Email: ‘ . $arrayObj->email;
    
    // count the number of properties in the object
    echo ‘Number of properties assigned to the object: ‘ . count($arrayObj);

Built\ |ndash|\ in Iterator classes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ArrayIterator class
~~~~~~~~~~~~~~~~~~~

.. code-block:: java

    class ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...  }

This iterator allows you to both unset and modify values and keys while iterating over arrays and objects. To explictily create an ArrayIterator, pass a PHP array() to the constructor.
Explicitly calling ``ArrayObject::getIterator()`` also returns an ArrayIterator.  ArrayIterator instances are created implicitly when **``foreach``** encounters an ArrayObject.

ArrayIterator wraps these PHP functions for built\ |ndash|\ in PHP arrays: ksort, natcasesort, natsort, uasort, and uksort.

.. code-block:: java

    ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...}
        //. . . snip
        public function asort ( void );
        public function ksort ( void );
        public function natcasesort ( void );
        public function natsort ( void );
        public function uasort ( string $cmp_function );
        public function uksort ( string $cmp_function );
    } 
       
You instantiate ArrayIterator either explicitly by passing a built-in array or implicitly by invoking ``foreach`` on an ArrayObject, which invokes ``ArrayObject::getIterator()``, which
returns an ArrayIterator.

Built\ |ndash|\ in Iterator classes continued
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RecursiveArrayIterator
~~~~~~~~~~~~~~~~~~~~~~

RecursiveArrayIterator adds two methods to ArrayIterator: ``getChildren()`` and ``hasChildren()``.

.. code-block:: java

    RecursiveArrayIterator extends ArrayIterator implements RecursiveIterator {

        /* Methods */
        /* Returns an iterator for the current entry if it is an array or object */
        public RecursiveArrayIterator getChildren ( void );

        /* Returns true if the current entry is an array or object */
        public bool hasChildren ( void );

        /* Inherits */
        public void ArrayIterator::append ( mixed $value );
        public void ArrayIterator::asort ( void );
        public ArrayIterator::__construct ([ mixed $array = array(); [, int $flags = 0 ]] );
        public int ArrayIterator::count ( void );
        public mixed ArrayIterator::current ( void );
        public array ArrayIterator::getArrayCopy ( void );
        public void ArrayIterator::getFlags ( void );
        public mixed ArrayIterator::key ( void );
        public void ArrayIterator::ksort ( void );
        public void ArrayIterator::natcasesort ( void );
        public void ArrayIterator::natsort ( void );
        public void ArrayIterator::next ( void );
        public void ArrayIterator::offsetExists ( string $index );
        public mixed ArrayIterator::offsetGet ( string $index );
        public void ArrayIterator::offsetSet ( string $index , string $newval );
        public void ArrayIterator::offsetUnset ( string $index );
        public void ArrayIterator::rewind ( void );
        public void ArrayIterator::seek ( int $position );
        public string ArrayIterator::serialize ( void );
        public void ArrayIterator::setFlags ( string $flags );
        public void ArrayIterator::uasort ( string $cmp_function );
        public void ArrayIterator::uksort ( string $cmp_function );
        public string ArrayIterator::unserialize ( string $serialized );
        public bool ArrayIterator::valid ( void );
    }

This iterator allows you to unset and modify values and keys while iterating over Arrays and Objects in the same way as the ArrayIterator. Additionally it is possible to iterate over the current iterator entry.
The use of ArrayIterator is straight forward, but limited to single dimensional arrays. Sometimes you’ll have a multidimensional array and you’ll want to iterate through the nested arrays recursively. In this case you can use RecursiveArrayIterator
See this `article <http://www.sitepoint.com/using-spl-iterators-1/>`_ for next topic.

What did the crap above mean?

Iterating recursive over composite structures
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Conceptually the RecursiveIterator iterator looks like this:

.. code-block:: java

     RecursiveIterator extends Iterator {
       
        public RecursiveIterator getChildren ( void )
        public bool hasChildren ( void )

        /* Inherited methods */
        abstract public mixed Iterator::current ( void )
        abstract public scalar Iterator::key ( void )
        abstract public void Iterator::next ( void )
        abstract public void Iterator::rewind ( void )
        abstract public boolean Iterator::valid ( void )
    }

``getChildren()`` must return an object that implements **RecursiveIterator**.

TODO: Other iterators. See todo in directory above.
