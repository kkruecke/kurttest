.. include:: <isopub.txt>

.. role:: kurt-code

Array\ |ndash|\ related implementations
=======================================

ArrayObject class
-----------------

An ArrayObject allows us to treat a class like it were also an array, allowing us to access its properties using array syntax. ArrayObject implements IteratorAggregate,
ArrayAccess , Serializable , and Countable. It also implements a number of its own member functions:

.. code-block:: java

    ArrayObject implements IteratorAggregate , ArrayAccess , Serializable , Countable {

        /* Constants */
        const integer STD_PROP_LIST = 1 ;
        const integer ARRAY_AS_PROPS = 2 ;
        /* Methods */
        public __construct ([ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator" ]]] )
 
        // ArrayAccess methods
        public bool offsetExists ( mixed $index )
        public mixed offsetGet ( mixed $index )
        public void offsetSet ( mixed $index , mixed $newval )
        public void offsetUnset ( mixed $index )

        // IteratorAggregate methods  
        public ArrayIterator getIterator ( void )

        // Serializable methods
        public void unserialize ( string $serialized )
        public string serialize ( void )

        // Countable method
        public int count ( void )

        // other public methods
        public void append ( mixed $value )
        public void asort ( void )
        public array exchangeArray ( mixed $input )
        public array getArrayCopy ( void )
        public int getFlags ( void )
        public string getIteratorClass ( void )
        public void ksort ( void )
        public void natcasesort ( void )
        public void natsort ( void )
        public void uasort ( callable $cmp_function )
        public void uksort ( callable $cmp_function )

        public void setFlags ( int $flags )

        public void setIteratorClass ( string $iterator_class )
    }    
    
ArrayObject::getIterator() will return an <TODO:add link here> ArrayIterator. If you extend ArrayObject, you can return your own iterator type, but it must derive
from ArrayIterator.

Usage
^^^^^

ArrayObject lets you treat an object like an array: it allows you to access its access properties using array syntax, and it allows iterating them via foreach. When you
create an ArrayObject from an associative array, the objects properties take on the name of the keys of the array.

.. code-block:: php
  
    <?php
    data = array(
        "name"  => "John Doe",
        "email" => "john@domain.com"
    );
    
    $arrayObj = new ArrayObject($data);
    // access the object properties using an array notation
    echo "Name is " . $arrayObj["name"] . ". Email is " . $arrayObj["email"];

You can also pass an object to the constructor, and it will create properties identical to the names of the properties of the object\ |mdash|\ provided they are public.

.. code-block:: php

    <?php
    class EmailUser { 
         public $name; 
         public $email;
         public function __construct($name, $email) { $this->name = $name; $this->email = $email; }
    }    
    
    $user = new EmailUser("John Doe", "john@domain.com");
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($user);
    
    // access the object properties using an array notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo "Full name: " . $arrayObj['name'] . " Email: " . $arrayObj['email'];

    // count the number of properties in the object
    echo "total properties is " . count($arrayObj);

``new ArrayObject($data)`` is equivalent to ``new ArrayObject($data, ArrayObject::STD_PROP_LIST)``. ``STD_PROP_LIST`` is the default behavior.
A good way to understand the usefulness ArrayObject is to compare it to the SimpleXML extension. SimpleXML objects are a type of ArrayObject in that a SimpleXML object 
also acts like an array which makes it efficient to use because you can just **foreach** or access one of the elements within the list. You don not
have to grab an array from the object and then iterate over and do something else with it if you want the tag name or an attribute.

When the constant ``ArrayObject::ARRAY_AS_PROPS`` is passed to the constructor or to the ``setFlags()`` method, it’s possible to handle the properties by means of an
object syntax. For example

.. code-block:: php

    $data = array(
        ‘name’  => ‘John Doe’,
        ‘email’ => ‘john@domain.com’
    );
    
    // create an instance of the ArrayObject class
    $arrayObj = new ArrayObject($data, ArrayObject::ARRAY_AS_PROPS);
    
    // access the object properties using an object notation
    // displays the following: Full name: John Doe Email: john@domain.com
    echo ‘Full name: ‘ . $arrayObj->name . ‘ Email: ‘ . $arrayObj->email;
    
    // count the number of properties in the object
    echo ‘Number of properties assigned to the object: ‘ . count($arrayObj);

ArrayIterator class
-------------------

.. code-block:: java

    class ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...  }

This iterator allows you to both unset and modify values and keys while iterating over arrays and objects. Some methods return an ArrayIterator like ``ArrayObject::getIterator()``.
ArrayIterator instances are created implicitly when **``foreach``** encounters an ArrayObject.

ArrayIterator wraps these PHP functions for built\ |ndash|\ in PHP arrays: ksort, natcasesort, natsort, uasort, and uksort.

.. code-block:: java

    ArrayIterator implements ArrayAccess , SeekableIterator , Countable , Serializable {//...}
        //. . . snip
        public function asort ( void );
        public function ksort ( void );
        public function natcasesort ( void );
        public function natsort ( void );
        public function uasort ( string $cmp_function );
        public function uksort ( string $cmp_function );
    } 
       
ArrayIterator can only iterator one dimensional arrays. To iterator over a multidimenstional array use ``RecursiverArrayIterator``.
