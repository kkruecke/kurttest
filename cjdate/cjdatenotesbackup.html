<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="screen" type="text/css" href="cjdatenotes.css">
<title>C.J. Date Notes</title>
<script type="text/javascript">
  var _gaq = _gaq || [];
   _gaq.push(['_setAccount', 'UA-21738682-4']);
   _gaq.push(['_trackPageview']);
   (function() { 
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
   _gaq.push(['_setAccount', 'UA-21738682-4']);
   _gaq.push(['_trackPageview']);
   (function() { 
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
   _gaq.push(['_setAccount', 'UA-21738682-3']);
   _gaq.push(['_trackPageview']);
   (function() { 
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>



<body>
<h2>Summary of Date's book Datebase in Depth</h2>
<h3>Tuples and Relations</h3>
<h4>tuple or tuple value </h4>
<p>Definition: Let <i>T1, T2, ..., Tn</i> (<i>n</i> &#8805;= 0) be type names, not all
necessarily distinct. Associate with each type <i>Ti</i> a distinct attribute name, <i>Ai</i>; each of the <i>n</i>
<u>attribute name&ndash;type name</u> pairs that results is an <i>attribute</i>.  Associate with each attribute a value
<i>vi</i> of type <i>Ti</i>; each of the <i>n</i> <u>attribute&ndash;value</u> combinations that results is a <i>component</i>.
The set of all <i>n </i>components thus defined, <i>t</i> say, is a <i>tuple value </i>(or just <i>tuple</i> for short) over the attributes <i>A1,
A2, ..., An</i>. The value <i>n</i> is the <i>degree</i> of <i>t</i>; a tuple of degree one is <i>unary</i>, a tuple of degree two is <i>binary</i>,
a tuple of degree three is <i>ternary</i>, ...., and more generally a tuple of degree <i>n </i> is <i>n-ary</i>. The set of all attributes is the
 <i>heading</i> of <i>t</i>.</p>
<p>To summarize, a component is an attribute plus its value. The set of all n components is a <em>tuple</em> or <em>tuple value</em>. The set of all <i>n</i> attributes
 is the <em>Heading</em>. <i>n</i> is the <em>degree</em> of the tuple. </p>
<p>In TUTORIAL D a <i>tuple type</i> name is written <i>TUPLE {H}</i>, where <i>{H} </i>is the heading. If we have, for example, two attributes 
<span class="mono">[STATUS: INTEGER]</span> and <span class="mono">[SUPPLIER_NAME: NAME]</span>, then the tuple type would be written as</p>
<pre> TUPLE { STATUS INTEGER, SUPPLIER_NAME NAME }</pre>
<p><u>Notice</u>, we are putting the attribute's name first followed by its type. This is the practice throughout. A sample tuple (tuple value) might be</p>
<pre>{ 20, NAME("General Electric Corporation") }</pre>
<p>An attribute's type does not have to be a SQL type (such as VARCHAR). In an attribute such as [EMPLOYEE: NAME], where NAME is the type 
 and EMPLOYEE is the attribute name, NAME would no doubt be implemented in our SQL database as two VARCHAR columns, first_name and last_name, and NAME
 equality would involve comparing both first_name and last_name.</p>
<h4>Atomicity</h4>
<p>The value of an attribute should be atomic: it should contain only one useful piece of information and must never require further parsing.</p>
<h4>Selectors</h4>
<p>A tuple value is returned or instantiated from a tuple<i> selector</i> invocation:</p> 
<pre>TUPLE { STATUS INTEGER, SUPPLIER_NAME NAME}            // <span class="verdana">type declaration</span>
TUPLE { STATUS 20, SUPPLIER_NAME NAME('Smith') }       // <span class="verdana">tuple selector instantiates the tuple
</pre>
<p>The attribute type is omitted in the selector because it can always be inferred from the type of the expression denoting the attribute value.</p>
<h4>A note on notation</h4>
<p>The keyword TUPLE does double duty in Tutorial D. It's used both to declare tuple <i>type names</i> and in tuple selector invocations.</p>
<h4>Extracting attribute values from tuples</h4>
<p>In Tutorial D the syntax from extracting an attribute value from a tuple is <i>attribute-name FROM tuple</i>. For example,</p>
<pre>TUPLE { STATUS 20, SUPPLIER_NAME NAME('Smith') } t; // <span class="verdana">selector invocation</span>
STATUS FROM  t;                                     // <span class="verdana">extraction of tuple attribute</span></pre>
<h4>The empty tuple</h4>
<p>A tuple with an empty heading has type <span class="mono">TUPLE {}</span> (it has no components). It is called the
<i>0-tuple</i> to emphasize that it is of degree zero. It is also sometimes called an <i>empty tuple</i>.</p>
<h4>Tuple equality</h4>
<p><i>Definition</i>: Tuples <i>t1 </i>and <i>t2</i> are <i>equal</i> if and only if they have the same attributes <i>A1,
A2, ..., An</i>. That is, they both are of the same tuple type.  And for all <i>i (i = 1, 2, ..., n)</i>, the value <i>vi</i>
of <i>Ai </i>in <i>t1 </i>is equal to the value in <i>t2</i>.</p>
<h4>Relations and relation values</h4>
<p><i>Definition: </i> Let <i>{H}</i> be a tuple heading and let <i>t1, t2, ..., tm</i> be distinct tuples with heading <i>{H}</i>. The
combination, <i>r</i> say, of <i>{H}</i> and the set of tuples <i>{t1, t2, ..., tm} </i>is a <i>relation value</i> (or just a <i>relation</i> 
for short) over the attributes <i>A1, A2, ..., An, </i>where <i>A1, A2, ..., An</i> are the attributes in <i>{H}</i>; the <i>heading </i>of
<i>r</i> is <i>{H}</i>; <i>r </i>has the same attributes (and hence the same attribute names, and types) and the same degree as that heading does.
The <i>body </i>of <i>r </i>is the set of tuples <i>{ t1, t2, ...,tm}.</i> The value <i>m </i>is the <i>cardinality </i>of <i>r.</i></p>
<p>The relational model is so called because it deals with certain abstractions that we can think of as "tables" but are known, formally,
as relations in mathematics.</p>
<p>You define a relation's type in <strong>TUTORIAL D </strong>as <strong><span class="mono">RELATION</span> {H}</strong>, where H is the heading. A <em>relation value</em>
(or <em>relation</em> for short) is its set of unique tuples. An example of the definition of a relation type</p>
<pre>RELATION { SNO SNO, SNAME NAME, STATUS INTEGER, CITY CHAR} </pre>
<p>Every relation value is returned by some relation selector invocation; for example, the relation type above might have this value.</p>
<pre>RELATION { TUPLE {SNO SNO('S1'), SNAME NAME('Smith'), STATUS 20, CITY 'London'},
           TUPLE {SNO SNO('S2'), SNAME NAME('Jones'), STATUS 15, CITY 'Miami'}, 
	   ...
         }
</pre>
<p>Relations by definition never contain duplicate tuples, and tuples never contain NULLs. Relation are by definition in first normal form (1NF)
because a tuple can have only one value for each of its attribute, which is the definition of 1NF. Both relations and their tuples contain
no sense of ordering. </p>
<h4>Empty relations</h4>
A relation can be empty, not containing any tuples. For every relation type is there is exactly one empty relation (of that paricular relation
type). Thus, two empty relations will both have equivalent empty bodies, but their Heading with be different.
<h4>TABLE_DUM and TABLE_DEE</h4>
<p>TABLE_DUM and TABLE_DEE are both relations of degree 0, meaning they have no attributes. They are of type <span class="mono">RELATION</span> {}.
TABLE_DUM has no tuples. TABLE_DEE has one tuple, the 0-tuple or empty tuple.</p>
<h3>Relation Variables</h3>
<h4>relation and relvar</h4>
<p>A relation is shorthand for <i>relation value</i> in the same way that integer is shorthand for <em>integer value</em>. Relvar is
shorthand for <i>relation variable</i>.  A relvar is a holder for a representation of a relation value. Relvars are analgous to variables in
a strongly typed language like, say, C++, and relations are likewise analogous to the values of those
variables at a given point in time. Relvars can be characterised as <i>base relvars</i> or <i>derived relvars</i> also know as views.
Here is the definition of a base relvars in Tutorial D.</p>
<pre>VAR S BASE RELATION { SNO SNO, SNAME NAME, STATUS INTEGER, CITY CHAR } Key { SNO }; </pre>
<h4>Updating of relvars is a set-at-a-time operation</h4>
<p>Unlike SQL, operations like INSERT, DELETE and UPDATE are, in the relational algebra, set-level operations not tuple-level opertaions: one
relation value, say <i>r1,</i> is always entirely replaced by another relation value, say, <i>r2.</i></p>
<h4>Candidate keys</h4>
<p><i>Definition</i>: A subset of the heading of a <strong>relvar</strong> is a candidate key K if it satisfies two conditions: </p>
<ul>
<li>The uniqueness property: no possible value of the relvar ever has two tuples with the same value for K.</li>
<li>The irreducibility property: no proper subset of the the candidate key has this uniqueness property.</li>
</ul>
<p>Keys are defined on relvars not relations. Keys imply certain integrity contraints, a uniqueness constraint in particular,
and integrity contraints apply to variables not values. Key values are tuples. <i>which means what????</i><--</p>
<p>Given this relation, which represents marriages
<pre>
RELATION { SPOUSE_A NAME, SPOUSE_B NAME, DATE_OF_MARRIAGE DATE }
</pre>
if we assume no polygamy and that no couples marry each other more than once, then this relvar</p>
<pre>
VAR MARRIAGE BASE RELATION { SPOUSE_A NAME, SPOUSE_B NAME, DATE_OF_MARRIAGE DATE }
</pre>
<p> would have three candidate keys:</p> 
<pre>
KEY {SPOUSE_A, SPOUSE_B}
KEY {SPOUSE_A, DATE_OF_MARRIAGE}
KEY {SPOUSE_B, DATE_OF_MARRIAGE}
</pre>
<p>So if this relvar contained a TUPLE of</p>
<pre>TUPLE { SPOUSE_A NAME("Betty Smith"), SPOUSE_B NAME("John Smith") DATE_OF_MARRIAGE DATE("09-11-1955") }
</pre>
<p>the value for the key <span class="mono">{SPOUSE_A, SPOUSE_B }</span> would be</p>
<pre>TUPLE { SPOUSE_A NAME("Betty Smith"), SPOUSE_B NAME("John Smith") }</pre> 
<h4>Primary key</h4>
<p>Any one of the candidate keys can be chosen as the <strong>primary
key</strong>.
Usually, however, the simplest candidate key is chosen. See pp. 63-64.</p>
<h4>Foreign keys</h4>
<p><i>Definition</i>: Let <i>R1</i> and <i>R2</i> be relvars, not necessarily distinct, and let <i>K</i> be a key for <i>R1</i>. Let <i>FK</i> be a
subset of <i>R2</i> that, possibly after some attribute renaming, involves exactly the same attributes as <i>K</i>. Then <i>FK</i> is a 
<i>foreign key</i> if and only if, at all times, every tuple in <i>R2</i> has an <i>FK</i> value that is equal to the <i>K</i> value in some
(necessarily unique) tuple in <i>R1</i> at the time in question.</p>
<p>Using this example of two relvars <span class="mono">BOOKS</span> and <span class="mono">BOOK_CHAPTERS</span></p>
<pre>VAR BOOKS BASE RELATION { BOOK_ID ISBN, BOOK_TITLE CHAR, BOOK_PRICE FLOAT}
KEY { BOOK_ID };<br />
VAR BOOK_CHAPTERS BASE RELATION { CHAPTER_ID INTEGER, CHAPTER_NUMBER INTEGER, BOOK_ID ISBN, CHAPTER_NAME CHAR }
KEY { CHAPTER_ID }
FOREIGN KEY { BOOK_ID} REFERENCES BOOKS;</pre>
<p><span class="mono"><strong>BOOK_ID</strong></span> in <span class="mono">BOOK_CHAPTERS</span> is a foreign key. While the same <span class="mono">BOOK_ID</span> value may
 occur in multiple tuples of <span class="mono">BOOK_CHAPTERS</span>, there is one and only one tuple in <span class="mono">BOOKS</span> with that same
 <span class="mono">BOOK_ID</span> value. The foreign key need not have the same name in the referencing relvar as in the referenced relvar. In
Tutorial D this fact would be shown using the RENAME operator. For example</p>
<pre>VAR BOOKS BASE RELATION { BOOK_ID ISBN, BOOK_TITLE CHAR, BOOK_PRICE FLOAT }
KEY { BOOK_ID };<br /> 
VAR BOOK_CHAPTERS BASE RELATION { CHAPTER_ID INTEGER, CHAPTER_NUMBER
INTEGER, BOOK_ISBN ISBN, CHAPTER_NAME CHAR }
KEY { CHAPTER_ID }
FOREIGN KEY { RENAME (BOOK_ISBN AS BOOK_ID) } REFERENCES BOOKS;
</pre>
<p>The foreign key can even reference the same relvar. That is, <i>R1</i> and <i>R2</i> in the foreign key definition can be the same relvar. For example,</p>
<pre>VAR EMP BASE RELATION { ENO ENO, ...., MNO ENO, ...}
KEY { ENO }
FOREIGN KEY { RENAME ( MNO AS ENO ) } REFERENCES EMP ;
</pre>
<p>Here attribue <span class="mono">MNO</span> denotes the employee number of the manager of the employee identified by <span class="mono">ENO</span>; thus the referencing
relvar and the referenced relvar are the same. In order for the tuple equality comparison to be valid we rename the <span class="mono">MNO</span>
attribute, so that it is of same type, since an attribute's name, like <span class="mono">ENO</span>, is part of its type.</p>
<p>SQL supports certain referential actions such as CASCADE, which, though very useful, even essential, are not strictly part of the relational algebra.
</p>
<h3>Base relvars and virtual relvars or views</h3>
<h4>base relation and base relvar.</h4>
<p>A base relation is a relation of some type with an initial value.</p>
<h4>view or virtual relvar</h4>
<p><i>Definition:</i> A <i>view</i> or <i>virtual relvar V</i> is relvar whose value at time <i>t</i> is derived by evaluting a certain relational
expression at that time <i>t</i>. The expression is specified when <i>V</i> is defined and must mention at least one relvar.</p>
<p>Virtual relvars can be used like base relvars because of <i>closure</i>.  We can define further views on top of them.</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>VAR LS VIRTUAL (S WHERE CITY = 'London');</td><td>CREATE VIEW LS AS (SELECT S.* FROM S WHERE S,CITY = 'London');</td></tr>
</tbody>
</table>
<p>Views can have candidate keys just like base relvars. They can have integrity constraints. We can update views (although
SQL's support is weak for this). You can discover a MySQL VIEW's underlying SELECT statement with this command:</h4>
<pre>
mysql&gt;  CREATE VIEW LS AS (SELECT S.* FROM S WHERE S,CITY = 'London');
mysql&gt;  SELECT LS, is_updatable, view_definition FROM INFORMATION_SCHEMA.VIEWS;
</pre>
<h4>snapshot versus view</h4>
<p>A snapshot is not a view because it has its own separate copy of the data.</p>
<h3>Relvars and Predicates</h3>
<p>The heading of a relvar is meant to represent a certain predicate, a generic statement about the real world.
It is the intended interpretation, the meaning, of the relvar, also called the <i>intention</i>.</p>
<p>A predicate is a truth-valued function that returns TRUE or FALSE. This if relvar <i>R</i> has predicate <i>P</i>, then every tuple <i>t</i> in
<i>R</i> at some given time can be regarded as a certain proposition derived by invoking <i>P</i> with the attribute values from <i>t</i> as arguments.
Every proposistion <i>p</i> obtained by substituting a tuples's values always evaluates to TRUE.
</p>
<p>So a given relvar contains, at any given time, all and only the tuples that represent true propositions (instantiations that return TRUE) of the
predicate.</p>
<p>A database should be thought of as a collection of facts or true propositions, in which the heading of a relvar represents a description of something
going on in the real world. This intended intrepretation, the real meaning of the relvar, is called the relvar's <em>Predicate</em>. The Predicate can
be though of as a truth-value function that when given specific values returns TRUE or FALSE. So the heading of every relation should have an associated
Predicate that describes the relation's real meaning. The Predicate is a function whose arguments are the names of the attributes in the heading of the
relation, and a relvar's contents, its tuples, then become true propositions (at a given point in time). While the tuples may change over time, the
Predicate does not. </p>
<h4>Formal Predicate Definition</h4>
<p><em>Predicate Definition:</em></p>
<p>Every relvar <em>R</em> has an associated Predicate <em>P</em>. <em>P</em> is the <em>intended interpretation</em> or 
<em>intension</em> for <em>R</em>. It does not change over time.  When the values of a tuple <em>p</em> are substitued in the revlar's predicate 
<em>P</em>, the resulting proposition is always true. A relvar, at any given time, contains <em>all</em> and <em>only</em> the tuples that represent true
propostions, true instantions of the predicate.</p>
<p><em>Extension of a Predicate</em></p>
<p>If <em>P</em> is the predicate of some relvar <em>R</em> whose value at some given time is <em>r</em>, then the body of <em>r</em> constitutes the
<em>extension</em> of <em>P</em> at that time. The extension varies over time, but the intention, the Predicate, does not.
</p>
<h4>Sample predicates</h4>
<p>Types are things in the real world we can talk about; relations are true statements about those things. Types are to relations as nouns are to
sentences. If we take, as an example, the relvar for the suppliers relation (on pp. 11, 61 in Date's book)
</p>
<pre>VAR S BASE RELATION { SNO SNO, SNAME NAME, STATUS INTEGER, CITY CHAR }
KEY {SNO };
</pre>
<p>the Predicate would be the following sentence (recalling that the attribute's name comes first in the declaration above, then its type) :</p>
<p><em>SNO</em> is a <strong>supplier part number</strong> for <strong>supplier name</strong> <em>SNAME</em> with <strong>status</strong> of <em>STATUS</em>,
 which means ..., and is located in <em>CITY</em> <strong>city</strong></p>
<p>Here is another example of the predicate for an email contacts
relvar.</p>
<pre>VAR EMAIL_CONTACTS BASE RELATION { CONTACT_ID INTEGER, NAME NAME, EMAIL EMAIL, OPT_OUT BOOLEAN }
KEY {CONTACTID};
</pre>
<p>The Predicate, the sentence describing the meaning of each
attribute, would be</p>
<p> <em>CONTACT_ID</em> is the <strong>unique identifier</strong> of someone <strong>named</strong> <em> NAME</em> whose <strong>email address</strong>
is <em>EMAIL</em> and whose <strong>opt status</strong> is <em>OPT_OUT</em>.</p>
<p>The current value of EMAIL_CONTACTS consists of all tuples that currently satisfies this Predicate.</p>
<h4>The principle of Orthogonality</h4>
<p>Database Constraints should not be easy to violate because duplicate information, dulicate tuples or subsets of tuples which
duplicate part of a larger tuple, could result. See the <a href="#orthogonality">principle of orthogonal design</a></p>
<h3>Relational Algebra</h3>
<p>The relational algebra operators are defined on relations and not strictly speaking on relvars, although their
application to relvars is no different. Relation operators are <i>generic</i>: they apply, in effect, to all possible relations.
They are also <i>read-only</i>. They read their operations and return a result. INSERT, UPDATE and DELETE (and relation assignment),
while they are relational operators, aren't technically part of the relational algebra.</p>
<h4>Some differences between SQL and Tutorial D</h4>
<ul>
<li>When a relational algebra operations, like UNION or JOIN, requires a correspondence between operand attributes to be established,
Tutorial D requires the attributes to have the same name.</li>
<li>Tutorial D sometimes needs to rename attributes to avoid naming clashes or mismatches. SQL usually doesn't</li>
<li>SQL requires most queries to conform to SELECT &#8212; FROM &#8212; WHERE template. Tutorial D has no analogous requirement.</li>
</ul>
<p>Tutorial D RENAME operator takes one relation as input and returns a relation identical to the input except that one of the attributes has a
different name. For example</p>
<table>
<thead class="realign"><tr><th><strong>Tutorial D RENAME</strong></th><th><strong>SQL equivalent</strong></th></tr>
</thead>
<tbody>
<tr>
<td>S RENAME (CITY AS SCITY)</td><td>SELECT S.SNO , S.NAME, S.STATUS, S.CITY AS SCITY FROM S</td></tr>
</tbody>
</table>
<h4>RESTRICT</h4>
<p>Let <i>bx</i> be a boolean expression involving zero or more attribute names such that all of the attributes mentioned
are atrributes of the same relation <i>r</i>. Then the <i>restriction</i> of <i>r</i> according to <i>bx</i>:</p>
<pre><i>r</i> WHERE <i>bx</i></pre>
<p>is the relation with a heading the sameas that of <i>r</i> and a body consisting of all typles of <i>r</i>for which <i>bx</i>
evaluates to TRUE. For example,</p>
<table>
<tbody>
<tr><td>S WHERE CITY = 'Paris'</td><td>SELECT S.* FROM S WHERE S.CITY = 'Paris'</td></tr>
</tbody>
</table>
<p>will not contain any duplicate tuples.</p>
<h4>PROJECT</h4>
<p>Let relation <i>r</i> have attributex X, Y,...Z (and possibly others). Then the <i>projection</i> of <i>r</i>
on <i>X, Y,...., Z</i>:</p>
<pre><i>r { X, Y, ..., Z }</i>
</pre>
<p>is a relation with (a) a heading derived from the heading of <i>r</i> by removing all attributes not mentioned in the set <i>{X, Y,
..., Z}</i> and (b) a body consistiting of all typles <i>{X x, Y y, ..., Z z} </i> such that a tuple appears in <i>r</i>
with <i>X</i> values <i>x</i>, <i>Y</i> values <i>y</i>, ..., and <i>Z</i> value <i>z</i>. For example,
</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>MySQL</th></tr>
</thead>
<tbody>
<tr><td>S { SNAME, CITY, STATUS}</td><td>SELECT DISTINCT S.SNAME, S.CITY, S.STATUS FROM S</td></tr>
</tbody>
</table>
<p>DISTINCT is needed in the SQL formulation to insure no duplicates occurs. The Tutorial D forumlation can also be expressed in
terms of the attributes to be discarded. Thus</p>
<pre>S { SNAME, CITY, STATUS }</pre>
<p>is equivalent to</p>
<pre>S { ALL BUT CITY }</pre>
<p>PROJECT has a higher precedence than other (all?) operators, so</p>
<pre>S JOIN P { PNO, CITY }</pre>
<p>is equivalent to</p>
<pre>S JOIN ( P { PNO, CITY } )</pre>
<h4>JOIN</h4>
<p><i>Definition:</i> Let relations <i>r</i> and <i>s</i> jave attributes <i>X1, X2, ..., Xm, Yq, Y2, ..., Yn, Z1, Z2, ..., Zp, </i> respectively;
in other words, the <i>Y's</i> (<i>n</i> of them) are the common attributes, the <i>X's</i> (<i>m</i> of them) are the other attributes of <i>r</i>,
and the <i>Z's</i> (<i>p</i> of them) are the other attributes of <i>s</i>. We can assume without loss of generality that none of the <i>X's</i>
has the same name as any of the <i>Z's</i>, thanks to the availability of RENAME. Now let the <i>X's</i> taken together be denoted just <i>X</i>,
and similarly for the <i>Y's</i> and the <i>Z's</i>. Then the <i>natural join</i>(<i>join</i> for short) of <i>r</i> and <i>s</i>:</p>
<pre>r JOIN s</pre>
<p>is a relation with (a) a heading that is the (set-theoretic) union of the heading of <i>r</i> and <i>s</i>
and (b) a body consisting of of the set of all tuples <i>t</i> such that <i>t</i> is the (set -theoretic) union of a tuple appearing in <i>r</i>
and a tuple appearing in <i>s</i>. In other words the heading is <i>(X, Y, Z)</i> and the body consists of all tuples <i>(X x, Y y, Z z)</i> such
that a tuple appears in <i>r</i> with <i>X</i> value <i>x</i> and <i>Y</i> value <i>y</i> and a tuple appears in <i>s</i> with <i>Y</i> value <i>y</i>
and <i>Z</i> value <i>z</i>.</p>
<p>Less formally, JOIN first locates tuples with the same values for the shared attribues. It then concatenates, joins, the unshared
attribute values of those same tuples to produce the result.</p>
<p>The closest SQL equivalent to the Tutorial D expression P JOIN S would be SELECT * FROM P NATURAL JOIN S, though not all SQL products
support this syntax; otherwise, one would have to list all the attributes</p>
<pre>SELECT P.PNO, P.PNAME, P.COLOR, P.WIEGHT, P.CITY, S.SNO, S.SNAME, S.STATUS FROM P, S WHERE P.CITY = S.CITY;</pre>
<p><i>Intersection</i> and <i>cartesian product</i> are special cases of JOIN. If <i>m = p = 0</i> (meaning there are no <i>X's</i> and not <i>Z's</i>,
and <i>r</i> and <i>s</i> are thus of the same type), then <i>r JOIN s</i> degenerates to <i>r INTERSECT s</i>. If <i>n = 0</i>, meaning there are
no <i>Y's</i> and <i>r</i> and <i>s</i> thus have no common attributes, <i>r JOIN s</i> degenerates to <i>r TIMES s</i>.</p>
<table>
<thead class="realign">
<tr>
<th>Tutorial D JOIN</th><th>SQL equivalent</th><th>SQL equivalent</th></tr>
</thead>
<tbody>
<tr><td>S JOIN SP</td><td>SELECT * FROM S NATURAL JOIN SP;</td><td>SELECT DISTINCT P.PNO, P.NAME, P.COLOR, P.WEIGHT, P.CTY, S.SNO, S.SNAME,
S.STATUS<br /> FROM S,SP WHERE S.SNO = SP.SNO;</td></tr>
</tbody>
</table>
<p>NATURAL JOIN does not require the use of DISTINCT because NATURAL JOIN will only show one SNO column, and since { SNO, PNO } is the primary
key of SP, we know the tuples will be distinct, and for a given SNO value, the PNO values will always differ.</p>
<p>SQL supports several types of join: NATURAL JOIN, JOIN, INNER JOIN, LEFT (OUTER) JOIN, and RIGHT (OUTER) JOIN. They are explained 
at <a href="http://www.w3schools.com/Sql/sql_join.asp">SQL JOINS</a>. The MySQL JOIN syntax is explained at
<a href="http://dev.mysql.com/doc/refman/5.1/en/join.html">MySQL JOIN SYNTAX</a>. Here are some sample MySQL joins queries.</p>
<p class="p-mono_indent">SELECT * FROM S NATURAL JOIN SP;</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th><th>PNO</th><th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P1</td><td>300</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P2</td><td>200</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P3</td><td>400</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P4</td><td>200</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P5</td><td>100</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P6</td><td>100</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td><td>P1</td><td>300</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td><td>P2</td><td>400</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P4</td><td>300</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P5</td><td>400</td></tr>
</tbody>
</table>
<p class="p-mono_indent">SELECT DISTINCT S.* FROM S NATURAL JOIN SP;</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
</tbody>
</table>
<p class="p-mono_indent">SELECT * FROM S LEFT JOIN SP USING(SNO);</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th><th>PNO</th><th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P1</td><td>300</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P2</td><td>200</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P3</td><td>400</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P4</td><td>200</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P5</td><td>100</td></tr>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td><td>P6</td><td>100</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td><td>P1</td><td>300</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td><td>P2</td><td>400</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P4</td><td>300</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td><td>P5</td><td>400</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td><td><i>NULL</i></td><td><i>NULL</i></td></tr>
</tbody>
</table>
<p class="p-mono_indent">SELECT DISTINCT S.* FROM S LEFT JOIN SP USING(SNO);</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p class="p-mono_indent">SELECT DISTINCT S.* FROM S LEFT JOIN SP USING(SNO) WHERE SP.SNO IS NOT NULL;</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
</tbody>
</table>
<p class="p-mono_indent">SELECT DISTINCT S.* FROM S LEFT JOIN SP USING(SNO);</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p>&nbsp;</p>
<h4>SEMIJOIN</h4>
<p>Many queries that require JOIN really require an extended form of the operator called SEMIJOIN. The <i>semijoin</i> of <i>r</i> and <i>s</i> is the join of <i>r</i> and <i>s</i>, projected back on the attributes of <i>r</i>. So,
for example, <span class="mono">S SEMIJOIN SP</span> is equivalent to <span class="mono">(S JOIN SP) { SNO, SNAME, STATUS, CITY }</span>. An application
of SEMIJOIN would be the query "Get suppliers who supply at least one part".</p>
<table>
<thead class="realign">
<tr>
<td><strong>Tutorial D SEMIJOIN</strong></td><td colspan="2" style="text-align: center"><strong>SQL equivalents</strong></td> </tr>
</thead>
<tbody>
<tr> <td>S SEMIJOIN SP</td><td>SELECT DISTINCT S.* FROM S NATURAL JOIN SP;</td><td>SELECT DISTINCT S.* FROM S,SP WHERE S.SNO = SP.SNO;</td>
</tr>
</tbody>
</table>
<p>The output would look like this.</p>
<table class="border">
<thead>
<tr><th>SNO</th> <th>SANME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
</tbody>
</table>
<p>A more user-friendly spelling of SEMIJOIN is MATCHING: <span class="mono">S MATCHING SP</span>. Finally, observe that if the heading of <i>s</i> is a subset of <i>r</i> (that is, <i>p = 0</i>. See the definition of JOIN), then <i>r</i> JOIN <i>s</i>
degenerates to <i>r</i> MATCHING <i>s</i>.  Likewise, if <i>m = 0</i>, <i>r</i> JOIN <i>s</i> degenerates to <i>s</i> MATCHING <i>r</i>.</p>
<h4>TABLE_DEE is the identity with respect to JOIN</h4>
<p>The concept pf JOIN can be extended to join several relvars, which would be written JOIN { r, s, ..., w} and means r JOIN s JOIN ... JOIN w.
Thus <i>r</i> JOIN <i>s</i> can also be written JOIN { r, s }.</p>
<p>The JOIN of no relations, written JOIN {}, is TABLE_DEE.  TABLE_DEE is of type RELATION {}; i.e., it has no attributes; and it
contains one tuple, the <i>0-tuple</i> or empty tuple. The join of any relation <i>r</i> with TABLE_DEE is simply <i>r</i>. As a consequence, the
join of no relations is TABLE_DEE.</p>
<p>Also <i>r</i> JOIN TABLE_DEE is the same as TABLE_DEE JOIN <i>r</i> because the result is simply the cartesian product.</p>
<h4>INTERSECT</h4>
<p>Interest requires the relations or relvars to be of the same type.</p>
<table>
<thead class="realign"><tr><th>Tutorial D</th><th>MySQL</th></thead> 
<tbody>
<tr><td>S { CITY } INTERSECT P { CITY }</td><td>SELECT DISTINCT S.CITY FROM S INTERSECT SELECT DISTINCT P.CITY FROM P</td></tr>
</tbody>
</table>
<p>Note, DISTINCT is not strictly needed above. INTERSECT will remove duplicates.</p>
<h4>UNION</h4>
<p>The types of the operands must be the same.</p>
<table class="mono_indent">
<tbody>
<tr><td>S { CITY } UNION P { CITY }</td> <td>SELECT DISTINCT S.CITY FROM S<br> UNION DISTINCT<br> SELECT DISTINCT P.CITY<br> FROM P</td> </tr>
</tbody>
</table>
<p>Since the default for UNION is UNION DISTINCT, DISTINCT is not strictly needed. As a consequence, the DISTINCTs following the two
SELECTs aren't needed (note: the default for SELECT is ALL rather than DISTINCT).</p>
<h4>MINUS and SEMIMINUS</h4>
<p>Definition: If <i>r</i> and <i>s</i> are of the same type, then <i>r</i> MINUS <i>s</i> consists of all typles that appear in <i>r</i>
but not in <i>s</i>.</p>
<table>
<thead class="realign">
<tr><th>Tutorial D MINUS</th><th>SQL equivalent</th></tr>
</thead>
<tbody>
<tr>
<td>S { CITY } MINUS P { CITY }</td><td>SELECT S.CITY<br /> FROM S<br /> EXCEPT<br /> SELECT P.CITY<br /> FROM P</td></tr>
</tbody>
</table>
<p>EXCEPT is the SQL equivalent of the relational algebra MINUS operator; however, not all SQL implementations support EXCEPT, including MySQL. An 
MySQL equivalent expression using a subquery is</p>
<table>
<thead class="realign">
<tr>
<th>Tutorial D MINUS</th><th>MySQL equivalent</th></tr>
</thead>
<tbody>
<tr>
<td>S { CITY } MINUS P { CITY }</td>
<td>SELECT S.CITY FROM S WHERE S.CITY NOT IN (SELECT DISTINCT P.CITY FROM P)</td>
</tr>
</tbody>
</table>
<p>We extract those cities from the supplier relvar that are not in the parts relvar. MINUS can be done more efficiently in MySQL using LEFT JOIN, as
<a href="http://www.bitbybit.dk/carsten/blog/?p=71">Doing Intersect and Minus in MySQL</a> explains. Using LEFT JOIN, the MySQL analogue of MINUS 
would be</p>
<table>
<thead class="realign">
<tr>
<th>MySQL equivalent of MINUS using LEFT JOIN</th></tr>
</thead>
<tbody>
<tr><td>SELECT DISTINCT S.* FROM S LEFT JOIN SP USING(SNO) WHERE SP.SNO IS NULL</td></tr>
</tbody>
</table>
<p>MINUS is just a special case of the more general SEMIMINUS. SEMIMINUS does not require both operands to be of the same type.  The definition of
<i>s</i> SEMIMINUS <i>r</i> is "<i>r</i> MINUS (<i>r</i> SEMIJOIN <i>s</i>)" which is the same as "<span class="mono"><i>r</i> MINUS (<i>r</i> MATCHING
<i>s</i>)</span>". Consider the query "Get suppliers who supply no parts at all":</p>
<table>
<thead class="realign">
<tr>
<th>Tutorial D SEMIMINUS</th><th>SQL equivalent</th></tr>
</thead>
<tbody>
<tr><td>S SEMIMINUS SP</td><td>SELECT S.*<br /> FROM S<br /> EXCEPT<br /> SELECT S.* <br /> FROM S, SP<br /> WHERE S.SNO = SP.SNO<br /></td></tr>
</tbody>
</table>
<p>Again, MySQL does not support EXCEPT. The MySQL analogue for SEMIMINUS would be</p>
<table>
<thead>
<tr style="margin-bottom: .5em;"><th colspan=2>MySQL analogues for SEMIMINUS</th></tr>
</thead>
<tbody>
<tr><td>SELECT DISTINCT S.* FROM S LEFT JOIN SP USING(SNO)<br /> WHERE SP.SNO IS NULL</td><td>SELECT DISTINCT S.* FROM S WHERE S.SNO NOT IN<br />
(SELECT DISTINCT S.SNO FROM S NATURAL JOIN SP)</td></tr>
</tbody>
</table>
<p>Tutorial D does provide the alternative, more user-friendly syntax of &nbsp;"<span class="mono">S NOT MATCHING SP</span>".
Thinking in terms of "NOT MATCHING" makes the MySQL expressions above perhaps more understandable.</p>
<h4>DIVIDE</h4>
<p>In relational algebra, the divisor is another relation S, whose heading must be a subset of the heading of R. The division is
over the common attribute(s), and the set of values used as the actual divisor are the values found in S.</p>
<p>DIVIDE is perhaps easier to first illustrate. The figure below shows a simple example of dividing a binary
relation R1 by a unary relation R2. The division is over the shared attribute I2. The divisor is the set {1,2,3}, these being the values
found in the shared attribute in R2. Inspecting the tuples of R1, the value 'a' occurs in tuples such that their I2 values
(that is, set of values for R1.I2) match the divisor (the set of values in the divisor).  So 'a' is included in the result, but 'b' is not because
there is no tuple with '3' as the I2 value and 'b' as the I1 value.</p>
<p><img src="./division-2.gif" alt="an image"></p>
<p><i>Definition</i>: Let <i>r</i> and <i>s</i> be such that the heading of <i>s</i> is a subset of the heading of <i>r</i>. Then
the <i>division</i> of <i>r</i> by <i>s</i>, <i>r</i> DIVIDEDBY <i>s</i> is shorthand for the following:</p>
<pre><i>r</i> { <i>X</i> } MINUS ( ( <i>r</i> { <i>X</i> } TIMES <i>s</i>) MINUS <i>r</i> ) { <i>X</i> }</pre>
<p>where X is the set-theoretic difference between the heading of <i>r</i> and that of <i>s</i>.  Let's use a example from the part and
suppliers database. Let's apply this definition to this example.</p>
<pre>SP { SNO, PNO } DIVIDEBY P { PNO }</pre>
<p>Using the definition, this would be re-written as </p>
<pre>SP { SNO } MINUS ( ( SP { SNO } TIMES P { PNO } ) MINUS SP { SNO, PNO } ) { SNO }</pre>
<!-- 
<p>To make this clear, we break it into three steps
<ol>
<li><span class="mono">R1 = SP { SNO } TIMES P { PNO }</span></li>
<li><span class="mono">R2 = R1 MINUS SP { SNO, PNO }</span></li>
<li><span class="mono">SP { SNO } MINUS R2 { SNO }</span></li>
</ol>
</p>
-->
<p>If look at these steps one-by-one, we would see the following.</p>
<p style="float: left; margin-left: 2em"><span class="mono">SP { SNO } <strong>TIMES</strong> P { PNO }</span></p>
<p style="float: left; margin-left: 4em"><span class="mono">SP <strong>{ SNO, PNO }</strong></span></p>
<p style="float: left; margin-left: 4em"><span class="mono">( SP { SNO } TIMES P { PNO } ) <strong>MINUS</strong> SP { SNO, PNO }</span></p>
<p class="clear"></p>
<!-- <table style="float: left; margin-left: 7em; margin-top: .6em"> -->
<table class="float-left_border" style="margin-left: 7em;">
<thead>
<tr><th>SNO</th><th>PNO</th></tr>
</thead>
<tbody>
<tr> <td>s1</td> <td>p1</td> </tr>
<tr><td>s1</td><td>p2</td></tr>
<tr><td>s1</td><td>p3</td></tr>
<tr><td>s1</td><td>p4</td></tr>
<tr><td>s1</td><td>p5</td></tr>
<tr><td>s1</td><td>p6</td></tr>
<tr><td>s2</td><td>p1</td></tr>
<tr><td>s2</td><td>p2</td></tr>
<tr><td>s2</td><td>p3</td></tr>
<tr><td>s2</td><td>p4</td></tr>
<tr><td>s2</td><td>p5</td></tr>
<tr><td>s2</td><td>p6</td></tr> 
<tr><td>s3</td><td>p1</td></tr>
<tr><td>s3</td><td>p2</td></tr>
<tr><td>s3</td><td>p3</td></tr>
<tr><td>s3</td><td>p4</td></tr>
<tr><td>s3</td><td>p5</td></tr>
<tr><td>s3</td><td>p6</td></tr>
<tr><td>s4</td><td>p1</td></tr>
<tr><td>s4</td><td>p2</td></tr>
<tr><td>s4</td><td>p3</td></tr>
<tr><td>s4</td><td>p4</td></tr>
<tr><td>s4</td><td>p5</td></tr>
<tr><td>s4</td><td>p6</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 10em;">
<thead>
<tr> <th>SNO</th> <th>PNO</th> </tr>
</thead>
<tbody>
<tr><td>s1</td><td>p1</td></tr>
<tr><td>s1</td><td>p2</td></tr>
<tr><td>s1</td><td>p3</td></tr>
<tr><td>s1</td><td>p4</td></tr>
<tr><td>s1</td><td>p5</td></tr>
<tr><td>s1</td><td>p6</td></tr>
<tr><td>s2</td><td>p1</td></tr>
<tr><td>s2</td><td>p2</td></tr>
<tr><td>s3</td><td>p3</td></tr>
<tr><td>s4</td><td>p2</td></tr>
<tr><td>s4</td><td>p4</td></tr>
<tr><td>s4</td><td>p5</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 12em;">
<thead>
<tr><th>SNO</th><th>PNO</th></tr>
</thead>
<tbody>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p1</strong></del></td></tr>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p2</strong></del></td></tr>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p3</strong></del></td></tr>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p4</strong></del></td></tr>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p5</strong></del></td></tr>
<tr><td><del><strong>s1</strong></del></td><td><del><strong>p6</strong></del></td></tr>
<tr><td><del><strong>s2</strong></del></td><td><del><strong>p1</strong></del></td></tr>
<tr><td><del><strong>s2</strong></del></td><td><del><strong>p2</strong></del></td></tr>
<tr><td><del><strong>s2</strong></del></td><td><del><strong>p3</strong></del></td></tr>
<tr><td>s2</td><td>p4</td></tr>
<tr><td>s2</td><td>p5</td></tr>
<tr><td>s2</td><td>p6</td></tr> 
<tr><td>s3</td><td>p1</td></tr>
<tr><td><del><strong>s3</strong></del></td><td><del><strong>p2</strong></del></td></tr>
<tr><td>s3</td><td>p3</td></tr>
<tr><td>s3</td><td>p4</td></tr>
<tr><td>s3</td><td>p5</td></tr>
<tr><td>s3</td><td>p6</td></tr>
<tr><td>s4</td><td>p1</td></tr>
<tr><td><del><strong>s4</strong></del></td><td><del><strong>p2</strong></del></td></tr>
<tr><td>s4</td><td>p3</td></tr>
<tr><td><del><strong>s4</strong></del></td><td><del><strong>p4</strong></del></td></tr>
<tr><td><del><strong>s4</strong></del></td><td><del><strong>p5</strong></del></td></tr>
<tr><td>s4</td><td>p6</td></tr>
</tbody>
</table>
<p style="float: left; margin-left: 2em; margin-top: .6em">&lt;==&gt;</p>
<table class="float-left_border" style="margin-left: 2em;">
<thead>
<tr><th>SNO</th><th>PNO</th></tr>
</thead>
<tbody>
<tr><td>s2</td><td>p4</td></tr>
<tr><td>s2</td><td>p5</td></tr>
<tr><td>s2</td><td>p6</td></tr> 
<tr><td>s3</td><td>p1</td></tr>
<tr><td>s3</td><td>p3</td></tr>
<tr><td>s3</td><td>p4</td></tr>
<tr><td>s3</td><td>p5</td></tr>
<tr><td>s3</td><td>p6</td></tr>
<tr><td>s4</td><td>p1</td></tr>
<tr><td>s4</td><td>p3</td></tr>
<tr><td>s4</td><td>p6</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>First, the cartesian product pairs the divisor P { PNO } &mdash; the set of unique PNO values from P &mdash; with each unique value of SNO in
the dividend SP.  Next MINUS finds potential attributes values that are in the final result. We can see this by noting that the set of tuples
whose SNO  value is 's1' have (collectively) a set of PNO values that matches the set of PNO values in the divisor. MINUS removes these 's1'-tuples 
completely. Next we project this intermediate result on <span>SNO</span>, which gives us.</p>
<p style="float: left; margin-left: 4em"><span class="mono">( ( SP { SNO } TIMES P { PNO } ) MINUS SP { SNO, PNO } ) <strong>{ SNO }</strong></span></p>
<p class="clear"></p>
<table class="float-left_border" style="margin-left: 19em;">
<thead>
<tr><th>SNO</th></tr>
</thead>
<tbody>
<tr><td>s2</td></tr>
<tr><td>s3</td></tr>
<tr><td>s4</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p> 
<p>These are the set of SNO values whose PNO values <i>do not</i> match those of the divisor. Finally, we substract these values from <span
class="mono">SP { SNO }</span>, which gives us back the 's1' value in SP.</p>
<p style="float: left; margin-left: 4em"><span class="mono">SP { SNO } <strong>MINUS</strong> ( ( SP { SNO } TIMES P { PNO } ) MINUS SP { SNO, PNO } ) { SNO }</span></p>
<p class="clear"></p>
<table class="float-left_border" style="margin-left: 20em;">
<thead>
<tr><th>SNO</th></tr>
</thead>
<tbody>
<tr><td>s1</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>So we see that <span class="mono">SP { SNO, PNO } DIVIDEBY P { PNO }</span> is:</p>
<table class="float-left_border" style="margin-left: 20em;">
<thead>
<tr><th>SNO</th></tr>
</thead>
<tbody>
<tr><td>s1</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>The result is loosely "supplier numbers for suppliers who supply all parts." This can be expressed SQL as</p>
<pre>
SELECT DISTINCT SPX.SNO
FROM SP AS SPX
WHERE NOT EXISTS
( SELECT P.PNO 
FROM P 
WHERE NOT EXITS
	( SELECT SPY.SNO
	  FROM SP AS SPY
	  WHERE SPY.SNO = SPX.SNO 
	  AND   SPY.PNO = P.PNO ) ) 
</pre>
<p>We claim that this query finds suppliers who supply (ship) all parts. Notice we want suppliers who have shipped parts, i.e., those SP.SNO
values <i>v</i>, such that there does not exist even one part, one P.PNO value, that is not found in those tuples of SP whose SP.SNO value
is <i>v</i>.</p>
<p>On the other hand, this query is loosely "supplier numbers for suppliers who do not supply all parts."</p>
<pre>
SELECT DISTINCT SPX.SNO
FROM SP AS SPX
WHERE EXISTS
( SELECT P.PNO 
FROM P 
WHERE NOT EXITS
	( SELECT SPY.SNO
	  FROM SP AS SPY
	  WHERE SPY.SNO = SPX.SNO 
	  AND   SPY.PNO = P.PNO ) ) 
</pre>
<p>Notice here we want suppliers who have shipped parts, i.e., those SP.SNO values <i>v</i>, such that there does exist at least one part,
one P.PNO value, that is not found in those tuples of SP whose SP.SNO value is <i>v</i>.</p>
<p>Note, any query that uses DIVIDEBY can be reformulated using relational comparison, which has the advantage of making the query clearer. A query 
using relational comparison to find "supplier numbers for suppliers who supply all parts" would be</p>
<pre>WITH (SP RENAME ( SNO AS X ) ) AS R:
S WHERE ( R WHERE X = SNO ) { PNO } = P { PNO };</pre>
<p><span class="mono">WITH AS</span> is explained below. How relational comparison, using <span class="mono">
WITH AS</span>,is more straightforward (than the SQL analogue for) DIVIDEBY is explained.</p>
<h4>EXTEND and SUMMARIZE</h4>
<p>Loosely, <i>extend</i> supports computation across tuples and <i>summarize</i> supports computation down tuples.</p>
<p><i>Definition</i>: The <i>extension</i> of relation <i>r</i>, written</p>
<pre>EXTEND <i>r</i> ADD (<i>exp</i> AS <i>X</i>)</pre>
<p>is a relation with a heading equal to <i>r</i> extended with the attribute <i>X</i> and a body consisting of all tuples <i>t</i> such
that <i>t</i> is a typle of <i>r</i> extended with a value for attribute <i>X</i> that is computed by evaluation <i>exp</i> on that tuple of
<i>r</i>. <i>r</i> must not have an attribute name <i>X</i> and <i>exp</i> must not refer to <i>X</i>.</p>
<p>For example, there are 454 grams to a pound. So we can extend a relation with a weight ( in lbs. ) attribute.</p>
<table class="mono_indent"> 
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead> 
<tr><td>EXTEND P ADD { WEIGHT * 454 AS GMWT }</td><td>SELECT P.*, ( P.WEIGHT * 454 ) AS GMWT FROM P</td></tr>
</table>
<p><span class="mono">ADD</span> is not addition. It means extend the heading of the relvar with an additional attribute, which follows <span
class="mono">AS</span>. The value of the extended attribute is computed by evaluating the expression before <span class="mono">AS</span>. Some other
examples using SQL.</p>
<pre>SELECT P.*, ( p.WEIGHT * 454 ) AS GMWT<br />FROM P<br />WHERE GMWT &gt; 7000.0</pre>
<p>Such a query can also be written closer in style to Tutorial D.</p>
<pre>SELECT TEMP.PNO, TEMPGMWT<br />FROM ( SELECT P.PNO, ( P.WEIGHT * 454 ) AS GMWT FROM P ) AS TEMP
WHERE TEMP.GMWT &gt; 7000.0</pre>   
<h4>SUMMARIZE</h4>
<p><i>Definition</i>: Let <i>r</i> and <i>s</i> be realtions such that <i>s</i> is of the same type as some projection of <i>r</i>, and
let the attributes of <i>s</i> be <i>A1, A2, A3, ...</i>. Then the <i>summarization</i></p>
<pre>SUMMARIZE <i>r</i> PER { <i>s</i> } ADD { <i>summary</i> AS <i>X</i> }</pre>
<p>is a relation whose heading is equal to the heading of <i>s</i> extended with the attribute <i>X</i>, and body consisting of all tuples
<i>t</i> such that <i>t</i> is a tuple of <i>s</i> extended with a value for attribute <i>X</i>, where <i>X</i> is computed by evaluating   
<i>summary</i> over all tuples of <i>r</i> that have the same value for attributes <i>A1, A2, ..., An</i> as tuples <i>t</i> does. <i>X</i> cannot 
be an attribute of <i>s</i> and <i>summary</i> must not refer to <i>X</i>. The cardinality of the resulting relation is equal to that of <i>s</i>,
and the degree is equal to that of <i>s</i> plus one. </p>
<p>As an example take</p>
<pre>SUMMARIZE SP PER ( S { SNO } ) ADD ( COUNT() AS P_COUNT)</pre>
<p>whose result would be</p>
<table class="border">
<thead>
<tr><th>SNO</th><th>P_COUNT</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>6</td></tr>
<tr><td>S2</td><td>2</td></tr>
<tr><td>S3</td><td>1</td></tr>
<tr><td>S4</td><td>3</td></tr>
<tr><td>S5</td><td>0</td></tr>
</tbody>
</table>
<p>While S { SNO } is not a projection of SP, it is of the same type as the projection SP { SNO }. The result will contain the same tuples as 
S { SNO }, the set of all suppliers, plus the attribute P_COUNT, where P_COUNT is the total number of suppliers in SP for that tuple's SNO value.</p>
<p>SUMMARIZE thus goes down 'columns' doing <i>summary</i> per tuple value in <i>s</i>. Notice that this analogous SQL statement</p>
<pre>SELECT SP.PNO, COUNT(*) AS P_COUNT FROM SP GROUP BY SP.SNO</pre>
<p>will only return tuples for suppliers S1, S2, S3 and S4, so it is not equivalent to the SUMMARIZE expression. This SQL expression is equivalent</p>
<pre>SELECT SP.SNO, TEMP.PRODUCT_COUNT FROM S, LATERAL ( SELECT COUNT(*) AS PRODUCT_COUNT FROM SP WHERE SP.SNO = S.SNO ) AS TEMP</pre>  
<p>does not contain a row ( tuple ) for S5, since S5 is not in SP.</p>
<p>If <i>s</i> is a projection of <i>r</i> (not just "of the same type as" some projection
of <i>r</i>) then the expression can be simplied slightly; instead of</p>
<pre>SUMMARIZE SP <strong>PER ( SP { SNO } )</strong> ADD ( MAX { QTY } AS MAXQ, MIN ( QTY ) AS MINQ )</pre>
<p>you can write</p>
<pre>SUMMARIZE SP <strong>BY ( SNO )</strong> ADD ( MAX { QTY } AS MAXQ, MIN ( QTY ) AS MINQ )</pre>
<p>Various types of summaries are supported in Tutorial D: <span class="mono">COUNT, SUM, AVG, MAX, MIN, COUNTD, SUMD, AVGD </span> ( where "D"
stands for "eliminate redundant duplicate values before summarizing" ).</p> 
<pre>SUMMARIZE SP PER ( SP { SNO } ) ADD ( MAX ( QTY ) AS MAXQ, MIN ( QTY ) AS MINQ )</pre>
<p>In this example <span class="mono">SUMMARIZE</span> has no <span class="mono">PER</span> specification.</p>
<pre>SUMMARIZE ( S WHERE CITY = 'London' ) ADD ( COUNT ( ) AS N )</pre>
<p>Since this summarize has no <span class="mono">PER</span> specification, the summarizing is done per <span class="mono">TABLE_DEE</span>, i.e., it is
shorthand for</p> 
<pre>SUMMARIZE ( S WHERE CITY = 'London' ) PER ( TABLE_DEE ) ADD ( COUNT ( ) AS N )</pre>
<p>Recall <span class="mono">TABLE_DEE</span> is a relation with no attributes and one tupe (the 0-tuple). <span class="mono">TABLE_DEE</span>
fits the definitino of SUMMARIZE because it is a projection of the relation in question, S, on the empty set of attributes.
The output of this SUMMARIZE therefore has on attribute and one type.<p>
<p>Finally, there is a difference between</p>
<pre>VAR N INTEGER;
N := COUNT ( S WHERE CITY = 'London' );</pre>
<p>SUMMARIZE returns a relation, but the aggregate operator above returns a scalar. It's true that it might be thought of as "returning" one scalar
value for each tuple in the PER relation, but that scalr value is then appended to that tuple to produce a tuple in the overall SUMMARIZE result.</p>
<p>SQL does have something analogous to the BY form of SUMMARIZE, but not the more general PER form. The SQL analog of</p>
<pre>SUMMARIZE SP BY { SNO } ADD ( SUM ( QTY ) AS TQ )</pre>
<p>is</p>
<pre>SELECT SP.SNO, SUM ( SP.QTU ) AS TQ</pre>
<p>Finally, here is an example of EXTEND expression that is logically equivalent to SUMMARIZE. The summarization expression of</p>
<pre>SUMMARIZE SP PER ( S { SNO } ) ADD ( COUNT ( ) AS NP )</pre>
<p>is equivalent to this EXTEND expression, which uses the WITH AS operator introduced next.</p>
<pre>WITH ( SP RENAME ( SNO AS X ) AS R :
EXTEND ( S { SNO } ) ADD ( COUNT ( R WHERE X = SNO ) AS NP )</pre>
<h4>WITH AS</h4>
<p>On p. 104 the Tutorial D <strong>WITH AS</strong> operator's use is illustrated to "get suppliers who supply all parts."</p>
<pre>WITH (SP RENAME ( SNO AS X ) ) AS R:
S WHERE ( R WHERE X = SNO ) { PNO } = P { PNO };</pre>
<p>This is a restriction, <span class="mono">S WHERE <i>exp1</i> = <i>exp2</i></span>, where <span class="mono"><i>exp1</i></span> is, <span
class="mon">( R WHERE X = SNO ) { PNO }</span> and <span class="mono"><i>exp2</i></span> is, <span class="mono">P { PNO }</span>. We examine each
supplier, say, Sx in relvar S, comparing Sx's associated SNO value to the SNO values in SP. That is the meaning of
<pre>( R WHERE X = SNO )</pre>
<p>For example, for  the tuple in S with SNO value of 'S1', after doing</p>
<pre>( R WHERE X = SNO )</pre>
<p> the resulting set of PNO values from SP corresponding to the 'S1' value from S would be: { P1, P2, P3, P4, P5, P6 }. Next we project this
result on PNO, which yields the same set of values, the set of unique part numbers supplied by 'S1'. Next we compare this result to
<span class="mono">P { PNO }</span>, the set of all unique part numbers.</p>
<pre>( R WHERE X = SNO ) { PNO } = P { PNO }</pre>
<p>Continuing the example using 'S1', the expression <span class="mono">( R WHERE X = SNO ) { PNO } = P { PNO }</span> would evaluate to TRUE. So the tuple of
S containing the SNO value of 'S1' would be in the final result. Thus, the resulting relation will be those tuples of S that represent suppliers
who supply (have shipped parts to customers) all parts. In the sample database there is only one such suppliers. Thus, the result is</p>
<pre>RELATION { TUPLE { SNO SNO('S1'), SNAME NAME('Smith'), STATUS 20, CITY 'London' } } </pre>
<p>So the forgoing query found "suppliers who supply all parts". And it is simplier than the earlier DIVIDEBY query, which was actually a
relational formulation of the query, "Get supplier numbers for supplier who <i>supply at least one part and in fact</i> supply all parts." 
<p>Here is another example a query using WITH AS that answers: "Get paris of supplier numbers, <i>Sx</i> and <i>Sy</i> say, such that 
<i>Sx</i> and <i>Sy</i> supply exactly the same set of parts."</p>
<pre>WITH ( S RENAME ( SNO AS SX ) { SX } AS RX,
( S RENAME ( SNO AS SY ) { SY } AS RY :
( RX JOIN RY ) WHERE ( SP WHERE SNO = SX ) { PNO } = ( SP WHERE SNO = SY ) { PNO }</pre>
<p>Again, this is a restriction of the result of a <span clas=="mon0">JOIN</span>: the outermost operation is <span class="mono">( RX JOIN RY ) WHERE
<i>exp1</i> = <i>expr2</i>.</p>
<p>Appending "SX &lt; SY" to the WHERE clause here would produce a slightly tidier result: it would eliminate pairs of the form (Sx, Sx) and ensure
that the pairs (Sx, Sy) and (Sy, Sx) don't appear (since JOIN is effectively the cartesian product).</p>
<h4>Expression Transformation</h4>
<p>Distributive, associate and commutative laws apply to various operations as mentioned on pp. 100-101. This allows an optimizer to rewrite
queries in such a way the performance is optimal.</p> 
<h4>INSERT, DELETE and UPDATE</h4>
<p>Strictly speaking relational algreba has no updateing (assignment) or comparison operators and no notion relvars. Operations like
UPDATE, INSERT and DELETE are shorthand for algebraic assigment operations. For example, given</p>
<pre>VAR PQ BASE RELATION { PNO PNO, QTY QTY } KEY { PNO };</pre>
<p>Inserting into  PQ</p>
<pre>INSERT PQ ( SUMMARIZE SP PER ( P { PNO } ) ADD ( SUM ( QTY ) AS QTY ) );</pre>
<p>is equivalent to the longhand assigment of:</p>
<pre>PQ := PQ UNION ( SUMMARIZE SP PER ( P { PNO } ) ADD ( SUM ( QTY ) AS QTY ) );</pre>
<p>A DELETE of</p>
<pre>DELETE S WHERE CITY = 'Athens';</pre>
<p>is equivalent to</p>
<pre>S := S WHERE NOT CITY = 'Athens';</pre>
<p>and an UPDATE of<p>
<pre>UPDATE P WHERE CITY = 'London' ( WEIGHT := 2 * WEIGHT, CITY := 'Oslo' );</pre>
<p>has the longhand equivalent:</p>
<pre>P := WITH ( P WHERE CITY = 'London' ) AS R1,
   ( EXTEND R1 ADD ( 2 * WEIGHT AS NEW_WEIGHT, 'Oslo' AS NEW_CITY ) ) AS R2,
   R2 { ALL BUT WEIGHT, CITY } AS R3,
   R3 RENAME { NEW_WEIGHT AS WEIGHT, NEW_CITY AS CITY } AS R4,
   P MINUS R1 AS R5 :
   R5 UNION R4;
</pre>
<p>First, R1 is the set of tuples to be updated, extended with the new weight and new city as R2. Then we throw away from R2 everything but the weight
and the city. This is R3. Then we rename the new weight and city with the proper attribute names of WEIGHT and CITY. This is R4. Then we identify
those tuples not to be updated (but to be retained). This is R5. Finally, the result is the union of R5 and R4.</p>
<h4>The basic SQL conceptual algorithm</h4>
<p>A SQL expression can be thought of as being implemented (at least conceptually) in three steps.
<ol>
<li> The FROM clause ...</li>
<li>Next, the WHERE clause ...</li>
<li></li>
</ol>
<p>To be done later...(See Simple SQL).</p>
<h4>Examples</h4>
<p>These are examples of Tutorial D and SQL analogues of various queries</p>
<p>Get supplier numbers for suppliers who supply part P1.</p>
<table>
<tbody>
<tr><td>(SP WHERE SNO = PNO('P1')) { SNO }</td><td>SELECT DISTINCT SP.SNO FROM SP WHERE SP.PNO = PNO('P1');</td></tr>
</tbody>
</table>
<p>Get suppliers with status in the range 15 to 25 inclusive.</p>
<table>
<tbody>
<tr><td>S WHERE STATUS &ge; 15 AND STATUS &le; 25</td><td>SELECT DISTINCT S.STATUS FROM S WHERE S.STATUS &ge; 15 AND STATUS &le; 25</td></tr>
</tbody>
</table>
<p>Get part numbers for parts supplied by a supplier in London.</p>
<table>
<tbody>
<tr><td>(SP MATCHING ( S WHERE CITY = 'London' )) { PNO }</td><td>SELECT DISTINCT SP.PNO FROM SP, S<br />WHERE S.CITY = CITY('London')<br />
AND<br /> SP.PNO = S.PNO;</td></tr>
</tbody>
</table>
<p>Comments: SP MATCHING ( S WHERE CITY = 'London' ) is SP JOIN S, with the result project back onto the attributes of SP.
Since we only want PNO, JOIN would have worked just as well.</p>
<p>Get part numbers for parts not supplied by any supplier in London.</p>
<table>
<tbody>
<tr><td>(SP NOT MATCHING ( S WHERE CITY = 'London' )) { PNO }</td><td>SELECT P.PNO FROM P<br />EXCEPT<br />SELECT SP.PNO<br />FROM SP, S<br />
WHERE SP.SNO = S.SNO AND S.CITY = 'London';</td></tr>
</tbody>
</table>
<p>Comments: NOT MATCHING is equivalent to SP SEMIMINUS (SP MATCHING (S WHERE CITY = 'London')), which is SP MINUS (SP MATCHING S). This query could 
also be expresse, if Tutorial D supports "not equal", as SP MATCHING (S WHERE CITY NOT = CITY('London').</p>
<p>Get city names for suppliers in which at least two two suppliers are located.</p>
<table>
<tbody>
<tr><td>(SUMMARIZE S BY CITY ADD (COUNT() AS CNUM)) WHERE CNUM &gt; 1</td><td> SELECT TEMP.CITY<br />
FROM (SELECT S.CITY, COUNT(*) AS CNUM FROM S GROUP BY S.CITY) AS TEMP<br />
WHERE TEMP.CNUM &gt; 1</td></tr>
</tbody>
</table>
<p>Comment: For the Tutorial D, we do a restrict on the result of summarize. For the SQL analogue, we also do COUNT(*) per city. GROUP BY specifies
how the count should be done; withtout it, we would simply get a total count of cities in each row of the result.</p>
<p>Get all pairs of part numbers such that some supplier supplies both of the indicated parts.</p>
<table>
<tbody>
<tr><td>WITH SP { SNO, PNO } AS Z:<br />( (Z RENAME (PNO AS X))<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JOIN<br />
&nbsp;&nbsp;(Z RENAME (PNO AS Y)) ) { X, Y }</tdv><td>SELECT XX.PNO AS X, YY.PNO AS Y <br />
FROM SP AS XX, SP AS YY<br />
WHERE XX.SNO = YY.SNO;</td></tr>
</tbody>
</table>
<p>Comments: From looking at relation SP it is clear that supplier S1 supplies every part listed in P; consequently, for any pairing of part numbers
(Px, Py) there will always exist a supplier, namely S1, who supplies both part numbers. Now how does the query ensure this? The SQL query select
pairs of part numbers, PNO, such that their suppliers are the same, XX.SNO = YY.SNO, i.e., these parts are both supplied by the same supplier. 
Note, DISTINCT is not needed because distinct values X and Y are being returned.</p>
<p>In the Tutorial D query, we, in essence, join two copies of SP, SP1 JOIN SP2, where the PNO attribute has been renamed in each copy, so that the join
occurs on SNO, the only remaining common attribute. The other two "PNO" columns are both included, as X and Y, giving pairs of part numbers (Px, Py)
such that they share a common supplier value, a common SNO value. So for, say the SNO value of 'S2', we would have the pairs (P1, P1), (P1, P2),
(P2, P1) and (P2, P2). For 'S4' we would have the pairs: (P2, P2), (P2, P4), (P4, P2) and (P4, P4). For SNO value of 'S1', we would have all possible
combinations of P1 through P6. Finally, we take the join result and project it onto { X, Y }. This eliminates duplicate tuples, duplicate pairs.</p>
<p>Get the total number of parts supplied by supplier S1.</p>
<table>
<tbody>
<tr><td>WITH (SP WHERE SNO = SNO('S1')) AS R:<br />
SUMMARIZE SP PER R { SNO } ADD (COUNT() AS TOTAL)</td><td>SELECT SP.SNO, TEMP.TOTAL FROM SP, LATERAL<br/>
&nbsp;&nbsp; (SELECT COUNT(*) AS TOTAL FROM SP WHERE SP.SNO = SNO('S1')) AS TEMP</tr>
</tbody>
</table>
<p>or with the count by itselfi</p>
<table>
<tbody>
<tr><td>EXTEND TABLE_DEE ADD (COUNT(SP WHERE SNO = 'S1') AS TOTAL)</td><td>SELECT COUNT(*) AS TOTAL FROM SP WHERE SNO = SNO('S1');</tr>
</tbody>
</table>
<p>Comments: Tutorial D also allows for the later expression to be written</p>
<pre>COUNT (SP WHERE SNO = SNO('S1'))</pre>
<p>Get supplier numbers for suppliers with a STATUS lower than that of supplier S1.</p>
<table>
<tbody>
<tr><td>(S WHERE STATUS &lt; STATUS FROM ( TUPLE FROM (S WHERE SNO = SNO('S1') )) { SNO }</td><td>SELECT S.SNO FROM S WHERE STATUS &lt;
(SELECT S.STATUS FROM S WHERE<br /> S.SNO = SNO('S1') ) ))</td></tr>
</tbody>
</table>
<p>Comments: The Tutorial D "TUPLE FROM" operator extracts a tuple from the restriction. Then the FROM operator extracts the STATUS attribute from the 
tuple. So we restrict S to the tuples where STATUS is always less than the STATUS of any of the tuples whose SNO value is S1.</p.
<h3>Integrity Constraints</h3>
<p>An integrity constraint, or just constraint, is just a formal name for <i>business rules</i>. Contraints guarantee consistentency. They cannot quarantee
correctness, which involves insuring that every relvar's predicate, it's fundamental meaning, has never been violated.</p>
<h4>Type  Constraints</h4>
<p>Type constraints are simply the set of legal values for the type. They are checked when the type's selector is invoked. In Tutorial D 
a type contraint looks like this</p>
<pre>TYPE POINT POSSREP CARTESIAN { X NUMERIC, Y NUMERIC CONSTRAINT SQRT (X ** 2, Y ** 2) &le; 100.0 };</pre>
<p>POSSREP here stands for "possible representation". If omitted, the POSSREP defaults to the same name as the type. The constraint is that  
points must lie within circle whose radius is 100. SQL does not support type constraints.</p>
<h4>THE_Operators</h4>
<p>The THE_operators (there is one for each component) return the components of the type. Given this POINT</p>
<pre>POINT P(NUMERIC(5), NUMERIC(5));</pre>
<p><span class="mono">THE_X(P)</span> returns the X component's value, and <span class="mono">THE_Y(P)</span> returns the Y component's value.</p>
<h4>Database constraints</h4>
<p>Database constraints are constraints on the values that can appear in a given database. They should be checked at the end of any statement that
assigns a value to some relvar in the database: in SQL at any INSERT or UPDATE. Attributes have a built-in type constaint because the attribute is always of a certain type. 
Together with type constraints they form the business rules of an application. A relvar constraint that involves just one relvar is a 
single-relvar constraint. In SQL database constaints are expressed by means of CREATE ASSERTION statements.  This single-relvar constaints checks
that "status values must be in the range 1 to 100 inclusive":</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>CONSTRAINT C1 IS_EMPTY (S WHERE STATUS &lt; 1 OR STATUS &gt; 100)</td><td>CREATE ASSERTION C1 CHECK<br /> (NOT EXISTS (SELECT S.* FROM S
WHERE S.STATUS &lt; 1 OR S.STATUS &gt; 100));</td></tr>
</tbody>
</table> 
<p>This constraint involves just a single attribute of a single relvar. The constraint "supplies in London must have status 20" would be written</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>CONSTRAINT C1 IS_EMPTY (S WHERE CITY = 'London' AND STATUS &#8800; 20);</td><td>CREATE ASSERTION C1 CHECK<br /> (NOT EXISTS (SELECT S.* FROM S
WHERE S.CITY = 'London' AND S.STATUS &lt;&gt; 20));</td></tr>
</tbody>
</table> 
<p>Although it involves two attributes, this is still a single-relvar constraint. Here is constraint that involves two revlars, a multi-relvar
constraint: "no supplier with status less than 20 can supply part P6."</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>CONSTRAINT C1 IS_EMPTY ((S JOIN SP) WHERE STATUS &lt; 20 AND PNO = PNO('P6'));</td><td>CREATE ASSERTION C1 CHECK<br /> (NOT EXISTS (SELECT S.* 
FROM S, SP WHERE S.SNO = SP.SNO AND S.STATUS &lt; 20 AND SP.PNO = PNO('P6')));</td></tr>
</table> 
<p>All the constraints (AND'ed together) involving a relvar R is the "relvar constraint" for R. The databse constraint for a given database DB is the
AND of all of the relvar constraints for the relvars in DB.</p>
<h4>Constraint examples</h4>
<p>All red parts must weight less than 50 lbs.</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>CONSTRAINT C1 IS_EMPTY (P WHERE COLOR = COLOR('Red')<br /> AND WEIGHT &ge; WEIGHT(50.0));</td><td>CREATE ASSERTION C1 CHECK (NOT EXISTS 
(SELECT P.* FROM P WHERE P.COLOR = COLOR('Red')<br /> AND P.WEIGHT &le; 50));</td></tr>
</tbody>
</table> 
<p>Every London supplier must supply part P2.</p>
<table>
<thead class="realign">
<tr><th>Tutorial D</th><th>SQL</th></tr>
</thead>
<tbody>
<tr><td>CONSTRAINT C1 IS_EMPTY<br /> (WITH (SP RENAME (SNO AS X)) AS R:<br /> &nbsp;S WHERE CITY = 'London'<br /> &nbsp;AND<br /> &nbsp;TUPLE {PNO
PNO('P2')} &notin; (R WHERE X = SNO) {PNO} );</td><td>CREATE ASSERTION C1 CHECK (NOT EXISTS<br /> (SELECT * FROM S WHERE S.CITY = 'London'
AND NOT EXISTS (SELECT * FROM SP WHERE SP.SNO = S.SNO<br /> &nbsp;AND SP.PNO = PNO('P2'))&nbsp; );</td></tr>
</tbody>
</table> 
<p>For further examples, see the answers to 6-16.</p>
<h3>Database Design Theory</h3>
<p>The intent of DB design theory is to reduce redundancy so that the database never is in an inconsistent state. While database design is ultimately a
 subjective endeavor, there are certain formal principles to keep in mind.</p>
<h4>Functional Dependency</h4>
<p>A functional dependency is a special type of single-relvar integrity constraint important in database normalization. If an attribute's value
depends on the value of another attribute, it is functionaly dependent on the other attribute. The formal definition is:</p>
<p><i>Definition:</i> Let <i>A</i> and <i>B</i> be subsets of the heading of relvar <i>R</i>, then <i>R</i> satisfies the functional dependency
(<i>FD</i>) <i>A</i> &rarr; <i>B</i> (read "<i>B</i> is functionally dependent on <i>A</i>" or "<i>A</i> functionaly determines <i>B</i>") if (and only
if), in every relation that is a legal value for <i>R</i>, whenever two tulpes have the same value for <i>A</i>, they also have the same value for <i>B</i>.</p>
<p><i>A</i> and(or) <i>B</i> can be sets of attributes. As an example of a functional dependency integrity constraint suppose we require that if two
 suppliers are in the same city, then they must have the same status, or { CITY } &rarr;
{ STATUS }.</p>
<table class="float-left_border">
<caption>S</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S3</td><td>Blake</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>In Tutorial D, this FD constraint can be expressed as:</p>
<pre>CONSTRAINT C1 COUNT(S { CITY }) = COUNT(S { CITY, STATUS });</pre>
<p>That is, whenever two cities are identical, the pair &lt;city, status&gt; will always identical.</p>
<p>A functional dependency (FD) clearly continues to remains valid if you add attributes to <i>A</i> (to the left side of the functional dependency) or
substract them  from  <i>B</i> (the right side of the functional dependency). Obviously, every relvar candidate key represents a functional dependency
constraint (from the key to the set of all the attributes of <i>R</i>, as well as from the key to every subset of attributes). As just noted, this
functional dependency remains valid if we add elements to the key. Adding attributes to a key creates what is called a <i>superkey</i>. A <i>superkey</i>
has the uniqueness property (as only one distinct tuple contains the superkey) that all keys must have, but it does not have the irreducibility 
property that a key must also have.</p> 
<h4>Boyce/Codd Normal Form</h4>
<p><i>Definition:</i> Relvar <i>R</i> is in BCNF if and only if, for every non-trivial functional dependency <i>A</i> &rarr; <i>B</i> satisfied by <i>R</i>, 
<i>A</i> is a superkey for <i>R</i>.</p>
<p>Trivial functional dependencies are the obvious sorts of FDs, in which the attributes on the left are a superset of the attributes on the right,
like these:</p>
<pre>{ CITY } &rarr; { CITY }<br />{ SNO } &nbsp;&rarr; { SNO }<br />{ CITY, STATUS } &rarr; { CITY}
</pre>
<p>The functional dependencies of a relvar in Boyce/Codd Normal Form (besides the trivial functional dependencies) are always <i>from</i> superkeys: 
a key or a set of attributes containing a key. To decompose a relvar <i>R</i> into BCNF, we decompose it into smaller relvars with fewer
 attributes. To ensure that no information is lost (which ultimatly means the predicate remains valid), we must restrict the decomposition 
to projections of <i>R</i> that when joined return the original relvar. So we use project as the decomposition operator for achieving Boyce-Codd NormalForm, 
and join as the recomposition operator.</p>
<p>We can decomposed RS, with its FD { CITY } &rarr; { STATUS }, into the following two projections:</p>
<table class="float-left_border">
<caption>RS</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p class="float-left" style="margin-left: 5em"><br /><br /> =&gt; </p>
<table class="float-left_border" style="margin-left: 7em">
<caption>SNC</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>London</td></tr>
<tr><td>S3</td><td>Blake</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>Athens</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em"> 
<caption>CS</caption>
<thead>
<tr><th>CITY</th><th>STATUS</th></tr>
</thead>
<tbody>
<tr><td>London</td><td>20</td></tr>
<tr><td>Paris</td><td>30</td></tr>
<tr><td>Athens</td><td>30</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>SNC still has SNO as a key. Its only functional dependencies are from its key. The FD { CITY } &rarr; { STATUS }
makes CITY the candidate key for CS. So both SNC and CS are in BCNF. We have eliminated the redundant STATUS values from RS, and we have not lost
any information: RS = SNC JOIN CS.</p>
<p>As another example, suppose we started with a suppliers relvar that included quanity:</p>
<table class="border"> 
<caption style="padding: .3em .1 em">STP</caption>
<thead>
<tr><th>SNO</th><th>STATUS</th><th>PNO</th><th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>20</td><td>P1</td><td>300</td></tr>
<tr><td>S1</td><td>20</td><td>P2</td><td>200</td></tr>
<tr><td>S1</td><td>20</td><td>P3</td><td>400</td></tr>
<tr><td>S1</td><td>20</td><td>P4</td><td>200</td></tr>
<tr><td>S1</td><td>20</td><td>P5</td><td>100</td></tr>
<tr><td>S1</td><td>20</td><td>P6</td><td>100</td></tr>
<tr><td>S2</td><td>10</td><td>P1</td><td>300</td></tr>
<tr><td>S2</td><td>10</td><td>P2</td><td>400</td></tr>
<tr><td>S3</td><td>30</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>20</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>20</td><td>P4</td><td>300</td></tr>
<tr><td>S4</td><td>20</td><td>P5</td><td>400</td></tr>
</tbody>
</table>
<p>Its key is still { SNO, PNO }. But this new suppliers relvar satisfies a FD of { SNO } &rarr; { STATUS }, and therefore it has duplicate STATUS
 values. To eliminate these redundant status values we decompose it into these two projections:</p>
<table class="float-left_border"> 
<caption style="padding: .3em .1 em">STP</caption>
<thead>
<tr><th>SNO</th><th>STATUS</th><th>PNO</th><th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>20</td><td>P1</td><td>300</td></tr>
<tr><td>S1</td><td>20</td><td>P2</td><td>200</td></tr>
<tr><td>S1</td><td>20</td><td>P3</td><td>400</td></tr>
<tr><td>S1</td><td>20</td><td>P4</td><td>200</td></tr>
<tr><td>S1</td><td>20</td><td>P5</td><td>100</td></tr>
<tr><td>S1</td><td>20</td><td>P6</td><td>100</td></tr>
<tr><td>S2</td><td>10</td><td>P1</td><td>300</td></tr>
<tr><td>S2</td><td>10</td><td>P2</td><td>400</td></tr>
<tr><td>S3</td><td>30</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>20</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>20</td><td>P4</td><td>300</td></tr>
<tr><td>S4</td><td>20</td><td>P5</td><td>400</td></tr>
</tbody>
</table>
<p class="float-left" style="margin-left: 6em"><br /><br /> =&gt; </p>
<table class="float-left_border" style="margin-left: 5em">
<caption>SP</caption>
<thead>
<tr><th>SNO</th><th>PNO</th><th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>P1</td><td>300</td></tr>
<tr><td>S1</td><td>P2</td><td>200</td></tr>
<tr><td>S1</td><td>P3</td><td>400</td></tr>
<tr><td>S1</td><td>P4</td><td>200</td></tr>
<tr><td>S1</td><td>P5</td><td>100</td></tr>
<tr><td>S1</td><td>P6</td><td>100</td></tr>
<tr><td>S2</td><td>P1</td><td>100</td></tr>
<tr><td>S2</td><td>P2</td><td>400</td></tr>
<tr><td>S3</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>P2</td><td>200</td></tr>
<tr><td>S4</td><td>P4</td><td>300</td></tr>
<tr><td>S4</td><td>P5</td><td>400</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em">
<caption>SS</caption>
<thead>
<tr><th>SNO</th><th>STATUS</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>20</td></tr>
<tr><td>S2</td><td>10</td></tr>
<tr><td>S3</td><td>30</td></tr>
<tr><td>S4</td><td>20</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>STP was not in BCNF because the FD { SNO } &rarr; { STATUS } was not from a superkey. In relvar SS the functional dependency is now from a superkey
 (in fact, a key), so SS is in BCNF, as is SP because { SNO, PNO } is the key. The decomposition is lossless: STP = JOIN (SP, SS).</p>
<h4>Lossles Decomposition and the Heath Theorem</h4>
<p>Decomposition is, as shown above, the process of taking projections of the original relvar. We must ensure, though, that
information is not lost: the join of the resulting relvars should be the original relvar. For example, consider
this decomposition of RS which loses information:</p>
<table class="float-left_border">
<caption>RS</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td style="background: #999999;">30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p class="float-left" style="margin-left: 6em"><br /><br /> =&gt; </p>
<table class="float-left_border" style="margin-left: 7em"> 
<caption>SNS</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td></tr>
<tr><td>S2</td><td>Jones</td><td>30</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td></tr>
<tr><td>S5</td><td>Admans</td><td>30</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em">
<caption>CS</caption>
<thead>
<tr><th>CITY</th><th>STATUS</th></tr>
</thead>
<tbody>
<tr><td>London</td><td>20</td></tr>
<tr><td>Paris</td><td>30</td></tr>
<tr><td>Athens</td><td>30</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>We have lost information: <span class="mono">RS &ne; JOIN(SNS, CS)</span>. We no longer know the city of the supplier. Is S2 located in Paris or 
Athens? Just like the first example we decomposed the orginal relvar using project. What condition(s) <i>must</i> be met in order for our projections to
 always be equal to their join, ensuring our decompositions lossless.</p>
<p>The Heath Theorem provides a sufficient condition for lossless decomposition. It tells us, if we meet the theorem's conditions,
the decomposition will be lossless. The theorem states:</p>
<p><i>Heath Theorem</i>: If we take subsets of the heading of <i>R</i>, say, <i>A</i>, <i>B</i>, and <i>C</i> such that their union is equal to the heading, and if
<i>R</i> satisfies the functional dependency constraint <i>A</i> &rarr; <i>B</i>, then <i>R</i> is equal to the join of its projections on 
<i>AB</i> and <i>AC</i>, where <i>AB</i> is the union of <i>A</i> and <i>B</i> and <i>AC</i> is the union of <i>A</i> and <i>C</i>.
</p>
<p>If you think about it, this theorem is just a formal statement of something obvious: if you decompose a relvar into two projections such that both
of the projections contain the "left side" of the functional dependency (the <i>A</i> in <i>A</i> &rarr; <i>B</i>), and one of the projections also contains
the "right side" (the <i>B</i> in <i>A</i> &rarr; <i>B</i>) and the other also contains the remaining attributes, those on neither side of the FD, then
join always gives you back the original relvar.</p>
<p>The Heath theorem gives us a sufficient condition to ensure the decomposition is lossles. It does not give a necessary condition. If the conditions
of the Heath Theorem are met, we know that our decomposition is lossless. It does not tell us however if other decompositions will be lossey or
lossless. What the necessary condition is for lossless decomposition is discussed in the answers section of chapter 7.</p>
<p>The RS and STP decomposition examples above are both instances where Heath's theorem tells us the decomposition will be lossless; we will not lose
information. In the case of relvar STP, for example, STP satisfies the FD { SNO } &rarr; { STATUS }. { SNO } corresponds to <i>A</i> in the
theorem, { STATUS } corresponds to B, and { PNO, QTY } to C. The union of A, B and C is clearly the heading of STP. { SNO, STATUS } corresponds to AB,
the union of A and B. { SNO, PNO, QTY } corresponds to AC, the union of A and B.  Finally, we applying the theorem, we see that</p>
<pre>JOIN(STP { SNO, STATUS }, STP { SNO, PNO, QTY }) = STP;</pre>
<p>Likewise, in the case of relvar RS, we have the FD { CITY } &rarr; { STATUS }. { CITY } is A, { STATUS } is B,
{ STATUS, CITY } is AB, and { SNO, SNAME, CITY } is AC. Again, we see that</p>
<pre>JOIN(RS { SNO, SNAME, CITY }, RS { STATUS, CITY }) = RS;</pre>
<p>Here is another decomposition example. We have a relvar in first normal form: all values are atomic. But we have a lot of redundancy.</p>
<table class="border">
<thead>
<tr><th>questionID</th><th>answertype</th><th>answer</th><th>answercode</th><th>id</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>experience1     </td><td>radio   </td><td>Very experienced         </td><td>very    </td><td> 1</td></tr>
<tr><td>experience1     </td><td>radio   </td><td>Somewhat experienced     </td><td>somewhat</td><td> 1</td></tr>
<tr><td>experience1     </td><td>radio   </td><td>Little experience        </td><td>little  </td><td> 1</td></tr>
<tr><td>experience1     </td><td>radio   </td><td>No experience            </td><td>none    </td><td> 1</td></tr>
<tr><td>experience2     </td><td>radio   </td><td>Very experienced         </td><td>very    </td><td> 2</td></tr>
<tr><td>experience2     </td><td>radio   </td><td>Somewhat experienced     </td><td>somewhat</td><td> 2</td></tr>
<tr><td>experience2     </td><td>radio   </td><td>Little experience        </td><td>little  </td><td> 2</td></tr>
<tr><td>experience2     </td><td>radio   </td><td>No experience            </td><td>none    </td><td> 2</td></tr>
<tr><td>experience3     </td><td>radio   </td><td>Very experienced         </td><td>very    </td><td> 3</td></tr>
<tr><td>experience3     </td><td>radio   </td><td>Somewhat experienced     </td><td>somewhat</td><td> 3</td></tr>
<tr><td>experience3     </td><td>radio   </td><td>Little experience        </td><td>little  </td><td> 3</td></tr>
<tr><td>experience3     </td><td>radio   </td><td>No experience            </td><td>none    </td><td> 3</td></tr>
<tr><td>easeofuse1      </td><td>radio   </td><td>Very simple to use       </td><td>vsimple </td><td> 6</td></tr>
<tr><td>easeofuse1      </td><td>radio   </td><td>Somewhat simple to use   </td><td>simple  </td><td> 6</td></tr>
<tr><td>easeofuse1      </td><td>radio   </td><td>Somewhat difficult to use</td><td>diff    </td><td> 6</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td>Very useful              </td><td>very    </td><td> 7</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td>Somewhat useful          </td><td>somewhat</td><td> 7</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td>Not that useful          </td><td>little  </td><td> 7</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td>Not useful at all        </td><td>none    </td><td> 7</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td>Very relevant            </td><td>very    </td><td> 8</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td>Somewhat relevant        </td><td>somewhat</td><td> 8</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td>A little relevant        </td><td>little  </td><td> 8</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td>Not relevant at all      </td><td>none    </td><td> 8</td></tr>
<tr><td>understand1     </td><td>radio   </td><td>Yes                      </td><td>yes     </td><td> 9</td></tr>
<tr><td>understand1     </td><td>radio   </td><td>No                       </td><td>no      </td><td> 9</td></tr>
<tr><td>recommend1      </td><td>radio   </td><td>Yes                      </td><td>yes     </td><td>10</td></tr>
<tr><td>recommend1      </td><td>radio   </td><td>No                       </td><td>no      </td><td>10</td></tr>
<tr><td>compare1        </td><td>radio   </td><td>More useful              </td><td>more    </td><td>11</td></tr>
<tr><td>compare1        </td><td>radio   </td><td>Equally useful           </td><td>equal   </td><td>11</td></tr>
<tr><td>compare1        </td><td>radio   </td><td>Less useful              </td><td>less    </td><td>11</td></tr>
<tr><td>review1         </td><td>textarea</td><td>NULL                     </td><td>        </td><td>12</td></tr>
<tr><td>useremotelabs   </td><td>radio   </td><td>Yes                      </td><td>yes     </td><td> 4</td></tr>
<tr><td>useremotelabs   </td><td>radio   </td><td>No                       </td><td>no      </td><td> 4</td></tr>
<tr><td>whynotremotelabs</td><td>textarea</td><td>NULL                     </td><td>        </td><td> 5</td></tr>
</tbody>
</table>
<p>We first notice that this relvar has the following functional dependencies:</p>
<p class="p-mono_indent">
{ id } &rarr; { questionID }.<br /> 
{ questionID } &rarr; { answertype }.<br /> 
{ id } &rarr; { answertype }.  
</p>
<p>The last dependency is due to the transitivity of these first two dependencies. We can normalize survey_answers by splitting it into two relations:
survey_questions and survey_answers.</p>
<table class="float-left_border">
<caption>survey_questions</caption>
<thead>
<tr><th>questionID</th><th>answertype</th><th>id</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>experience1     </td><td>radio   </td><td> 1</td></tr>
<tr><td>experience2     </td><td>radio   </td><td> 2</td></tr>
<tr><td>experience3     </td><td>radio   </td><td> 3</td></tr>
<tr><td>easeofuse1      </td><td>radio   </td><td> 6</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td> 7</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td> 8</td></tr>
<tr><td>understand1     </td><td>radio   </td><td> 9</td></tr>
<tr><td>recommend1      </td><td>radio   </td><td>10</td></tr>
<tr><td>compare1        </td><td>radio   </td><td>11</td></tr>
<tr><td>review1         </td><td>textarea</td><td>12</td></tr>
<tr><td>useremotelabs   </td><td>radio   </td><td> 4</td></tr>
<tr><td>whynotremotelabs</td><td>textarea</td><td> 5</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em">
<caption>survey_answers</caption>            
<tr><th>answer</th><th>answercode</th><th>id</th><tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>Very experienced         </td><td>very    </td><td> 1</td></tr>
<tr><td>Somewhat experienced     </td><td>somewhat</td><td> 1</td></tr>
<tr><td>Little experience        </td><td>little  </td><td> 1</td></tr>
<tr><td>No experience            </td><td>none    </td><td> 1</td></tr>
<tr><td>Very experienced         </td><td>very    </td><td> 2</td></tr>
<tr><td>Somewhat experienced     </td><td>somewhat</td><td> 2</td></tr>
<tr><td>Little experience        </td><td>little  </td><td> 2</td></tr>
<tr><td>No experience            </td><td>none    </td><td> 2</td></tr>
<tr><td>Very experienced         </td><td>very    </td><td> 3</td></tr>
<tr><td>Somewhat experienced     </td><td>somewhat</td><td> 3</td></tr>
<tr><td>Little experience        </td><td>little  </td><td> 3</td></tr>
<tr><td>No experience            </td><td>none    </td><td> 3</td></tr>
<tr><td>Very simple to use       </td><td>vsimple </td><td> 6</td></tr>
<tr><td>Somewhat simple to use   </td><td>simple  </td><td> 6</td></tr>
<tr><td>Somewhat difficult to use</td><td>diff    </td><td> 6</td></tr>
<tr><td>Very useful              </td><td>very    </td><td> 7</td></tr>
<tr><td>Somewhat useful          </td><td>somewhat</td><td> 7</td></tr>
<tr><td>Not that useful          </td><td>little  </td><td> 7</td></tr>
<tr><td>Not useful at all        </td><td>none    </td><td> 7</td></tr>
<tr><td>Very relevant            </td><td>very    </td><td> 8</td></tr>
<tr><td>Somewhat relevant        </td><td>somewhat</td><td> 8</td></tr>
<tr><td>A little relevant        </td><td>little  </td><td> 8</td></tr>
<tr><td>Not relevant at all      </td><td>none    </td><td> 8</td></tr>
<tr><td>Yes                      </td><td>yes     </td><td> 9</td></tr>
<tr><td>No                       </td><td>no      </td><td> 9</td></tr>
<tr><td>Yes                      </td><td>yes     </td><td>10</td></tr>
<tr><td>No                       </td><td>no      </td><td>10</td></tr>
<tr><td>More useful              </td><td>more    </td><td>11</td></tr>
<tr><td>Equally useful           </td><td>equal   </td><td>11</td></tr>
<tr><td>Less useful              </td><td>less    </td><td>11</td></tr>
<tr><td>NULL					 </td><td>NULL    </td><td>12</td></tr>
<tr><td>Yes                      </td><td>yes     </td><td> 4</td></tr>
<tr><td>No                       </td><td>no      </td><td> 4</td></tr>
<tr><td>NULL                     </td><td>NULL    </td><td> 5</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>The functional dependencies for the new survery_questions revlar are still the same:</p>
<p class="p-mono_indent">
{ id } &rarr; { questionID }.<br /> 
{ questionID } &rarr; { answertype }.<br /> 
{ id } &rarr; { answertype }.  
</p>
<p>And since the candidate keys for the new survey_questions relvar are { questionID } and {id}, this means survery_questions is in BCNF: all its
functional dependencies are <i>from</i> attributes that contain candidate keys. Functional dependencies can be from sets of attributes (more than one), but here
the FDs are from sets containing only one attribute.
</p> 
<p>What about the relvar survey_answers? First, we notice there is an entity integrity problem with id values of 12 and 5, but we can just delete those
tuples because id is not a candidate key here. It is a foreign key referring to the candidate key for survey_questions. As long as there is an 
existing id in survey_questions for every id in survey_answers referential integrety will not be violated. So there is no danger in deleting these two
tuples.</p>
<p>The new survey_answers appears to have the function dependency { answer } &rarr; { answercode}. Boyce Codd Normal Form requires all functional
dependencies to be <i>from</i> supersets, but { answer } contains neither one of the two candidate keys for survey_answers, {answer, id} and 
{answercode, id}, meaning our new survery_answers is still not in BCNF. We need to decompose this survey_answers relvar further. Consider this
decomposition of survey_answers into survey_answer and answer_choices:</p>
<table class="float-left_border"> 
<caption>survey_answers</caption>
<thead>
<tr><th>answercode</th><th>id</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>very    </td><td> 1</td></tr>
<tr><td>somewhat</td><td> 1</td></tr>
<tr><td>little  </td><td> 1</td></tr>
<tr><td>none    </td><td> 1</td></tr>
<tr><td>very    </td><td> 2</td></tr>
<tr><td>somewhat</td><td> 2</td></tr>
<tr><td>little  </td><td> 2</td></tr>
<tr><td>none    </td><td> 2</td></tr>
<tr><td>very    </td><td> 3</td></tr>
<tr><td>somewhat</td><td> 3</td></tr>
<tr><td>little  </td><td> 3</td></tr>
<tr><td>none    </td><td> 3</td></tr>
<tr><td>vsimple </td><td> 6</td></tr>
<tr><td>simple  </td><td> 6</td></tr>
<tr><td>diff    </td><td> 6</td></tr>
<tr><td>very    </td><td> 7</td></tr>
<tr><td>somewhat</td><td> 7</td></tr>
<tr><td>little  </td><td> 7</td></tr>
<tr><td>none    </td><td> 7</td></tr>
<tr><td>very    </td><td> 8</td></tr>
<tr><td>somewhat</td><td> 8</td></tr>
<tr><td>little  </td><td> 8</td></tr>
<tr><td>none    </td><td> 8</td></tr>
<tr><td>yes     </td><td> 9</td></tr>
<tr><td>no      </td><td> 9</td></tr>
<tr><td>yes     </td><td>10</td></tr>
<tr><td>no      </td><td>10</td></tr>
<tr><td>more    </td><td>11</td></tr>
<tr><td>equal   </td><td>11</td></tr>
<tr><td>less    </td><td>11</td></tr>
<tr><td>yes     </td><td> 4</td></tr>
<tr><td>no      </td><td> 4</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em">   
<caption>answer_choices</caption>
<thead>
<tr><th>answer</th><th>answercode</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>Very experienced         </td><td>very    </td></tr>
<tr><td>Somewhat experienced     </td><td>somewhat</td></tr>
<tr><td>Little experience        </td><td>little  </td></tr>
<tr><td>No experience            </td><td>none    </td></tr>
<tr><td>Very simple to use       </td><td>vsimple </td></tr>
<tr><td>Somewhat simple to use   </td><td>simple  </td></tr>
<tr><td>Somewhat difficult to use</td><td>diff    </td></tr>
<tr><td>Somewhat useful          </td><td>somewhat</td></tr>
<tr><td>Not that useful          </td><td>little  </td></tr>
<tr><td>Not useful at all        </td><td>none    </td></tr>
<tr><td>Very relevant            </td><td>very    </td></tr>
<tr><td>Somewhat relevant        </td><td>somewhat</td></tr>
<tr><td>A little relevant        </td><td>little  </td></tr>
<tr><td>Not relevant at all      </td><td>none    </td></tr>
<tr><td>Yes                      </td><td>yes     </td></tr>
<tr><td>No                       </td><td>No      </td></tr>
<tr><td>More useful              </td><td>more    </td></tr>
<tr><td>Equally useful           </td><td>equal   </td></tr>
<tr><td>Less useful              </td><td>less    </td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>Both relvars appear to be in BCNF. The only candidate key for survery_answers is its entire heading { answercode, id }. But since survery_answers
only has trivial functional dependencies, it is in BCNF.  The only candidate key for answer_choices is { answer }.  Since answer_choices has the FD 
{ answer }  &rarr; { answercode}, which is a dependency <i>from</i> a key, it also is in BCNF. But we now have a different soft of problem. If we tried
to join these two relations together on the common foreign key answercode, we would have no idea whether id 1 corresponds to answer "Very experienced"
or  answer "Very relevant". We have lost information, making this a lossy decomposition.</p>
<p>So we try yet again.</p>
<table class="float-left_border">
<caption>survey_answers</caption>
<thead>
<tr><th>answer</th><th>id</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>Very experienced         </td><td> 1</td></tr>
<tr><td>Somewhat experienced     </td><td> 1</td></tr>
<tr><td>Little experience        </td><td> 1</td></tr>
<tr><td>No experience            </td><td> 1</td></tr>
<tr><td>Very experienced         </td><td> 2</td></tr>
<tr><td>Somewhat experienced     </td><td> 2</td></tr>
<tr><td>Little experience        </td><td> 2</td></tr>
<tr><td>No experience            </td><td> 2</td></tr>
<tr><td>Very experienced         </td><td> 3</td></tr>
<tr><td>Somewhat experienced     </td><td> 3</td></tr>
<tr><td>Little experience        </td><td> 3</td></tr>
<tr><td>No experience            </td><td> 3</td></tr>
<tr><td>Very simple to use       </td><td> 6</td></tr>
<tr><td>Somewhat simple to use   </td><td> 6</td></tr>
<tr><td>Somewhat difficult to use</td><td> 6</td></tr>
<tr><td>Very useful              </td><td> 7</td></tr>
<tr><td>Somewhat useful          </td><td> 7</td></tr>
<tr><td>Not that useful          </td><td> 7</td></tr>
<tr><td>Not useful at all        </td><td> 7</td></tr>
<tr><td>Very relevant            </td><td> 8</td></tr>
<tr><td>Somewhat relevant        </td><td> 8</td></tr>
<tr><td>A little relevant        </td><td> 8</td></tr>
<tr><td>Not relevant at all      </td><td> 8</td></tr>
<tr><td>Yes                      </td><td> 9</td></tr>
<tr><td>No                       </td><td> 9</td></tr>
<tr><td>Yes                      </td><td>10</td></tr>
<tr><td>No                       </td><td>10</td></tr>
<tr><td>More useful              </td><td>11</td></tr>
<tr><td>Equally useful           </td><td>11</td></tr>
<tr><td>Less useful              </td><td>11</td></tr>
<tr><td>Yes                      </td><td> 4</td></tr>
<tr><td>No                       </td><td> 4</td></tr>
</tbody>
</table>            
<table class="float-left_border" style="margin-left: 4em">
<caption>answer_choices</caption>
<thead>
<tr><th>answer                    </th><th> answercode  </th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>Very experienced         </td><td>very    </td></tr>
<tr><td>Somewhat experienced     </td><td>somewhat</td></tr>
<tr><td>Little experience        </td><td>little  </td></tr>
<tr><td>No experience            </td><td>none    </td></tr>
<tr><td>Very simple to use       </td><td>vsimple </td></tr>
<tr><td>Somewhat simple to use   </td><td>simple  </td></tr>
<tr><td>Somewhat difficult to use</td><td>diff    </td></tr>
<tr><td>Somewhat useful          </td><td>somewhat</td></tr>
<tr><td>Not that useful          </td><td>little  </td></tr>
<tr><td>Not useful at all        </td><td>none    </td></tr>
<tr><td>Very relevant            </td><td>very    </td></tr>
<tr><td>Somewhat relevant        </td><td>somewhat</td></tr>
<tr><td>A little relevant        </td><td>little  </td></tr>
<tr><td>Not relevant at all      </td><td>none    </td></tr>
<tr><td>Yes                      </td><td>yes     </td></tr>
<tr><td>No                       </td><td>no      </td></tr>
<tr><td>More useful              </td><td>more    </td></tr>
<tr><td>Equally useful           </td><td>equal   </td></tr>
<tr><td>Less useful              </td><td>less    </td></tr>
</tbody>
</table>
<p class=clear>&nbsp;</p>
<p>This time, not only are both relations in BCNF, but if you join them together on answer, you get back the exact relation we had before.
This is a nonloss decomposition, and we note that this decomposition complies with the criteria of Heath's theorem. To confirm that both the new
survey_answers and answer_choices are in BCNF, we see that   </p> 
<h4>Join dependencies</h4>
<p>A join dependency or <strong>JD</strong> is a set of projections on a relation which, when joined together, returns the original relation. The
formal definition of a join dependency is:</p>
<p><i>Definition</i>: Let <i>A</i>, <i>B</i>, <i>C</i>, ..., <i>Z</i> be subsets of the heading of a relvar <i>R</i>. Then <i>R</i> satisfies the
<i>join dependency</i> (JD)</p> 
<pre>&lowast; { A, B, ..., Z }</pre>
if and only if every relation that is a valid value for <i>R</i> is equal to the join of its projections on <i>A</i>, <i>B</i>, <i>C</i>, ..., 
<i>Z</i>, or </p>
<pre>JOIN ( R { A }, R { B }, ..., R { Z } ) = R;</pre>
<p>To say a relvar <i>R</i> can be losslessly decomposed into certain projections on <i>A</i>, <i>B</i>, <i>C</i>, ..., <i>Z</i> is to
say that it satisfies the JD <span class="mono">&lowast; { A, B, ..., Z }</span>. Join dependencies are just another way of describing nonlossless
decompositions of a relvar.</p>
<p>It also follows from the the Heath theorem that every FD is a JD. Take the revlar RS above. It has the FD { CITY } &rarr; { STATUS }.
We first decomposed it into the relvars SNC and CS, with attributes of { SNO, SNAME, CITY } and { CITY, STATUS }, respectively. RS has thus satisfied the
join dependency &lowast; { { SNO, SNAME, CITY }, { CITY, STATUS } }. Likewise, when survey_answers had three attributes&mdash;{id, answer, answercode}&mdash;
it really had only one join dependency: &nbsp;<span class="mono">&lowast; {{id, answer}, {answer, answer_code}}</span>. </p>
<p>The existence of FDs and multi&ndash;valued dependencies (MVDs) implies that certain decompositions have lossless join. That is, FDs and MVDs imply
corresponding JDs. JDs, therefore, constitute a generalization of FDs and MVDs. As such, while every FD and MVD can be stated as an equivalent JD, there
can be JDs which are not FDs or MVDs.</p>
<pre>&lowast; { {id, answer}, {answer,answercode} }</pre>
<p>This means that { id, answer } and { answer, answercode } were the only two subsets in the original survey_answers that could be nonlossly decomposed into
two separate relations. So, in order to satisfy Boyce/Codd Normal Form, that's just what we did.</p> 
<h4>Fifth Normal Form</h4>
<p>Superkeys always imply certain functional dependencies (from the superkeys). Since every FD is also a JD (according to the Heath Theorem), superkeys
 always imply certain join dependencies. Take our suppliers relvar SS for example. { SNO } is a superkey (actually a key). SS satisfies the JD of</p>
<pre>&lowast; { {SNO, SNAME}, { SNO, STATUS }, { SNO, CITY } }
</pre> 
<p>The definition of 5th Normal Form (5NF) is:</p>
<p><i>Definition</i>: Relvar <i>R</i> is in 5NF if and only if every non-trivial join dependency satisfied by <i>R</i> is implied by the superkeys of 
<i>R</i>
</p>
<p>A trivial join dependency is a join dependency in which one of the subsets of the heading is the entire heading. Obviously every relvar has trivial
 join dependencies because a subset consisting of the entire header of a relvar can be joined with any other subset of the relvar.  Also the same subset consisting of all the attributes of
 the header can be joined with TABLE_DEE.</p>
<p>Most relvars that are in BCNF are also in 5NF. The exceptions are small. The following theorem explains that the only time when a BCNF relvar could
 possibly not be in 5NF, could possibly have a nontrivial JD that does not consist entirely of superkeys, is when there are keys with more than one attribute.
</p>
<p><i>Theorem</i>: Let <i>R</i> be a relvar in BCNF (or even just a 3NF relvar) and let <i>R</i> have no composite keys (that is, keys consisting of two or
more attributes), then <i>R</i> is in 5NF.</p>
<p>So if you can get to BCNF (which is easy enough) and there aren't any composite keys in your BCNF relvar, you don't have to worry about the complexities
of general JDs and 5NF: you know without have to think about the matter any further that the relvar is simply in 5NF.</p>
<h4>What does 5NF mean?</h4>
<p>If a relvar is in 5NF, the only nontrivial JDs are those implied by superkeys. The only lossless projection decompostions are ones in which every
projection is on the attributes of some superkeys; each such projection includes some key of <i>R</i>. As a consequence, the corresponding
"recomposition" joins are all <strong>one-to-one (from one tuple to one tuple)</strong>, and no redunancies are or can be eliminated by the decompostions
 ("joins are all one-to-one" means:  "the recomposition join is a <a href="http://mathworld.wolfram.com/Bijection.html">bijection</a>. In
 other words A JOIN B means A and B have some superkey in common (not necessarily just one attribute) and each tuple in A corresponds to exactly one
 tuple in B and vice versa." See <a href=f="http://tinyurl.com/ll8f3d">Dbforums reply</a>:)</p>
<p>5NF does not necessarily mean that all possible redundancy has been eliminated, however. It says that further nonloss decomposition of a 5NF relvar <i>R</i>
 into projections, while it might be possible, won't eliminate any redundancies. But this does not mean that <i>R</i> is redundancy free. Certain types
of redundancies cannot be reduced through projections. Consider the following 5NF relvar SPJ which suffers from redundancy. Its predicate is: Supplier
 SNO supplies part PNO to project JNO in quanity QTY. The sole key is { SNO, PNO, JNO }.</p>
<table class="border">
<caption>SPJ</caption>
<thead>
<tr><th>SNO</th><th>PNO</th><th>JNO<th>QTY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>P1</td><td>J1</td><td>200</td></tr>
<tr><td>S1</td><td>P3</td><td>J4</td><td>700</td></tr>
<tr><td>S2</td><td>P3</td><td>J1</td><td>400</td></tr>
<tr><td>S2</td><td>P3</td><td>J2</td><td>200</td></tr>
<tr><td>S2</td><td>P3</td><td>J3</td><td>200</td></tr>
<tr><td>S2</td><td>P3</td><td>J4</td><td>500</td></tr>
<tr><td>S2</td><td>P3</td><td>J5</td><td>600</td></tr>
<tr><td>S2</td><td>P3</td><td>J6</td><td>400</td></tr>
<tr><td>S2</td><td>P3</td><td>J7</td><td>800</td></tr>
<tr><td>S2</td><td>P5</td><td>J1</td><td>100</td></tr>
</tbody>
</table>
<p>We see the fact that supplier S2 supplies part P3 repeated several times. There are other another redundancies. The fact that part P3 is supplied to 
project J4 (JNO stands for project number) is repeated. So is the fact that J1 is supplied by supplier S2. The only nontrivial functional dependency
satisfied by this relvar is this functional dependency:</p>
<pre>{ SNO, PNO, JNO } &rarr; { QTY }</pre>
which is an arrow out of a superkey. In other words, QTY depends on all three of SNO, PNO and JNO, and it can't appear in a relvar with anything
less than all three. Hence, there is no nonloss decomposition that can remove the redundancies. The only JD the relvar satisfies is the trivial JD  
&lowast; { {SNO, PNO, JNO, QTY} }.</p>
<p>It is always possible to decompose a non-5NF. Because 5NF is the final normal form with respect to projection as the decomposition operator,
it is sometimes called <i>projection/join</i> normal form to stress that the point so long as we limit ourselves to projection as the decomposion
 operator and join as the recomposition operator.</p>
<p>Finally, keep in mind to say that a revlar is in BCNF does not mean that it is not in 5NF (though it usually is).</p>
<p>Join dependency means that an table, after it has been decomposed into two or more smaller tables, must be capable of being joined again on common 
keys to form the original table. Stated another way, 5NF indicates when an entity cannot be further decomposed using projections.</p>
<p>If we examine survery_questions again, which was in BCNF</p> 
<table class="border">
<caption>survey_questions</caption>
<thead>
<tr><th>questionID      </th><th>answertype</th><th>   id </th></tr>
</thead>
<tr><td>experience1     </td><td>radio   </td><td> 1</td></tr>
<tr><td>experience2     </td><td>radio   </td><td> 2</td></tr>
<tr><td>experience3     </td><td>radio   </td><td> 3</td></tr>
<tr><td>easeofuse1      </td><td>radio   </td><td> 6</td></tr>
<tr><td>usefulness1     </td><td>radio   </td><td> 7</td></tr>
<tr><td>relevance1      </td><td>radio   </td><td> 8</td></tr>
<tr><td>understand1     </td><td>radio   </td><td> 9</td></tr>
<tr><td>recommend1      </td><td>radio   </td><td>10</td></tr>
<tr><td>compare1        </td><td>radio   </td><td>11</td></tr>
<tr><td>review1         </td><td>textarea</td><td>12</td></tr>
<tr><td>useremotelabs   </td><td>radio   </td><td> 4</td></tr>
<tr><td>whynotremotelabs</td><td>textarea</td><td> 5</td></tr>
</table>
<p>we notice that it has these join dependencies:</p>
<p class="p-mono_indent">&lowast;{ {id, questionID}, {questionID,answertype} }<br />
&lowast;{ {questionID, id}, {id,answertype} }
</p>
<p>survey_questions could easily be further nonloss decomposed into two separate relations&mdash;in two different ways! So why don't we need to decompose it?
Well, not only is survey_questions already in BCNF, but it's also in 5th Normal Form. This means that each join dependency is satisfied by superkeys: {id, questionID} is a
 superkey, {questionID,answertype} is also a superkey, and so are the two attribute sets in the second JD. 
<h4>More on the meaning of 5NF</h4>
<p>What does a JD really mean intuitively? Take this simplify version of SPJ without the QTY attribute? The predicate for SPJ is: Supplier SNO supplies
 part PNO to project JNO. The sole key is { SNO, PNO, JNO }.</p> 
<table class="border">
<caption>SPJ</caption>
<thead>
<tr><th>SNO</th><th>PNO</th><th>JNO</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>P1</td><td>J2</td></tr>
<tr><td>S1</td><td>P2</td><td>J1</td></tr>
<tr><td>S2</td><td>P1</td><td>J1</td></tr>
<tr><td>S1</td><td>P1</td><td>J1</td></tr>
</tbody>
</table>
<p>Let's attach a real-world meaning to SPJ. Suppose SPJ tells us that all three of the following are true propostions:</p>
<ol>
<li>Smith supplies monkey wrenches to some project (think of S1 as Smith and P1 as monkey wrenches).</li>
<li>Somebody supplies monkey wrenches to the Manhattan project (think of P1 as monkey wrenches and J1 as the Manhattan project).</li>
<li>Something is supplied to the Manhattan project by Smith (think of J1 as the Manhattan project and S1 as Smith)</li>
</ol>
<p>Then is the following proposition true?</p>
<ol start=4>
<li>Smith supplies monkey wrenches to the Manhattan project (S1 supplies P1 to project J1).</li>
</ol>
<p>Normally, propositions 1, 2 and 3 would not imply proposition 4. We know that Smith supplies wrenches to <i>some</i> project (say,
project <i>z</i>) from proposition 1, that some supplier (say, supplier <i>x</i>) supplies monkey wrenches to the Manhattan project (from proposition 2),
 and that Smith supplies some part (say, part <i>y</i>) to the Manhattan project&mdash;but we cannot validly infer, just on the basis of the three propositions,
 that <i>x</i> is Smith or <i>y</i> is monkey wrenches or <i>z</i> is the Manhattan project.</p>
<p>Here is how a join dependency helps supply the answer. SPJ satisfies the join dependency &lowast; { { SNO, PNO }, { PNO, JNO }, { SNO, JNO } }, which we
 will abbreviate as &lowast; { SP, PJ, SJ }.  This JD tell us that SPJ satisfies the following obvious constraint:</p>
<pre>IF &lt;s,p&gt; &isin; SP AND &lt;p,j&gt; &isin; PJ AND &lt;s,j&gt; &isin; SJ THEN &lt;s,p,j&gt; &isin; SPJ
</pre>  
<p>For example, the tuples &lt;S1, P1&gt;, &lt;P1, J1&gt; and &lt;S1, J1&gt; appear in SP, PJ, and SJ, respectively, therefore the tuple &lt;S1, P1, J1&gt;
will obviously appear in their join SPJ. If we look at it from a different slightly different angle, we see that the tuple &lt;s, p&gt; appears in SP if 
(and only if) there exists some value <i>z</i> such that &lt;s, p, z&gt; appears in SPJ. Likewise, the tuple &lt;p, j&gt; appears in PJ if (and only if)
 there exists some value <i>x</i> such that &lt;x, p, j&gt; appears in PJ, and the tuple &lt;s, j&gt; appears in SJ if (and only if) &lt;s, y, j&gt;
 appears in SJ for some <i>y</i>. So we see that the earlier constraint is logically equivalent to this one:</p>
<pre>IF for some x, y, z   &lt;s,p,z&gt; &isin; SPJ AND
                      &lt;x,p,j&gt; &isin; SPJ AND
                      &lt;s,y,j&gt; &isin; SPJ
THEN                  &lt;s,p,j&gt; &isin; SPJ
</pre>  
<p>Given SPJ above, tuples &lt;<strong>S1</strong>,<strong>P1</strong>,J2&gt;, &lt;S2,<strong>P1</strong>,<strong>J1</strong>&gt;
 and &lt;<strong>S1</strong>,P2,<strong>J1</strong>&gt; all appear in SPJ, and therefore so does &lt;<strong>S1</strong>,<strong>P1</strong>,<strong>J1
</strong>&gt;. The join dependecy &lowast; { SP, PJ, SJ } tells us that, given propositions 1, 2 and 3, proposition 4 is also true. We can validly
infer proposition 4 from propositions 1, 2, and 3.</p>
<p>This constraint has a cyclic nature (IF <i>s</i> is connect to <i>p</i> and <i>p</i> is connected to <i>j</i> and <i>j</i> is connected back to <i>s</i> again,
THEN <i>s</i> and <i>p</i> and <i>j</i> must all be directly connected, in the sense that they must all appear together in the same tuple). Such cyclic
constraints are instances when we might have a relvar that is in BCNF but not in 5NF. Such cyclic constraints are, though, quite rare in practice.</p>
<h4>Order of Normalization</h4>
<p> Well, unless we get a data set into First Normal Form, we aren't dealing with relations at all&mdash;so it must go first. And if a relation is in 5th
 Normal Form, it's also in BCNF, so theoretically we could try to skip BCNF altogether. However, generally it's much easier to deal with functional 
dependencies than join dependencies (can you imagine figuring out all JDs for the original survey_answers?), so going for Boyce/Codd Normal Form is the
 natural progression.
</p>
<p>And once relations are in BCNF, most of the time they will also be in 5th Normal Form&mdash;in fact, if a BCNF relation has a primary key which contains
 only one attribute, you can bet on it. But still, it's good to use 5th Normal Form as a final check.</p> 
<h4>Normalization and Common sense</h4>
<p>Normalization theory formalizes, explicitly describes, what are certain commonsense principles of design.</p>
<h4>Normalization and Dependency Preservation</h4>
<p>The objective of reducing redundancy can conflict with the objective of dependency preservation. Consider the following relvar:</p>
<pre>ADDR { STREET, CITY, STATE, ZIP }
</pre>
<p> Assume ADDR has these FDs:</p>
<pre>{ STREET, CITY, STATE } &rarr; { CITY }
{ ZIP } &rarr; { CITY, STATE }</pre>
<p>Since ZIP is not a key ADDR is not in BNCF. If we apply Heath's theorem and decompose it into BCNF projections:</p>
<pre>ZCS { ZIP, CITY, STATE }
    KEY { ZIP }

ZS  { ZIP, STREET }
    KEY { ZIP, STREET }
</pre>
<p>The original FD of { STREET, CITY, STATE } &rarr; { CITY } is gone. It is satisfied by the join of ZCS and ZS, but not by either of those projections.
As a result, ZCS and CS cannot be independently updated. For example, if ZCS and CS have these values:</p>
<table class="float-left_border"> 
<caption>ZCS</caption>
<thead>
<tr><th>ZIP</th><th>CITY</th><th>STATE</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>10003</td><td>New York</td><td>NY</td></tr>
<tr><td>10111</td><td>New York</td><td>NY</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 4em">   
<caption>CS</caption>
<thead>
<tr><th>ZIP</th><th>STREET</th></tr>
</thead>
<tbody style="font-family: Verdana">
<tr><td>10003</td><td>Broadway</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>If we attempt to insert the tuple &lt;10111, Broadway&gt; into ZS, we will violate the "missing" FD, which says there can only be on zip code
for any given street in the same city and state. However, this fact can't be determined without examining projection ZCS as well as projection
ZS. For precisely this kind of reason, the dependency preservation objective says: <i>don't split dependencies acrosss projections</i>.</p>
<p>A FD is a single relvar constraint. When a FD is eliminated during decomposition, it changes to become a multi-relvar constraint. The dependency
preservation principle is revelant when you need the restraint to remain a single-relvar restraint.</p>
<h4><a name="orthogonality">Orthogonality</a></h4>
<p>Normalization is intended to reduce redundancy <i>within</i> relvars. Orthogonality refers to avoiding redundancy <i>across</i> relvars, avoiding
 duplicate tuples in two or more distinct relvars. Duplicate tuples can occur when constraints overlap. For example, if relvar SA below consists of
suppliers who are in Paris, and relvar SB is suppliers who either aren't in Paris or who have STATUS of 30, this overlap leads to duplicate tuples.</p>
<table class="float-left_border">
<caption>SA</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS<th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S2</td><td>Jones</td><td>10</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 5em">
<caption>SB</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS<th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Jones</td><td>20</td><td>London</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td><td>London</td></tr>
<tr><td>S5</td><td>Adams</td><td>30</td><td>Athens</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>Tuple S3 must appear in both relvars. If it didn't it would violate their constraints. Obviously, if we never have relvars of the same type, we will
never have duplicate tuples. But we must also take into account subsets of the attributes of a tuple. For example,</p>
<table class="float-left_border">
<caption>SX</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>STATUS</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>20</td></tr>
<tr><td>S2</td><td>Jones</td><td>10</td></tr>
<tr><td>S3</td><td>Blake</td><td>30</td></tr>
<tr><td>S4</td><td>Clark</td><td>20</td></tr>
<tr><td>S5</td><td>Adams</td><td>30</td></tr>
</tbody>
</table>
<table class="float-left_border" style="margin-left: 5em">
<caption>SY</caption>
<thead>
<tr><th>SNO</th><th>SNAME</th><th>CITY</th></tr>
</thead>
<tbody>
<tr><td>S1</td><td>Smith</td><td>London</td></tr>
<tr><td>S2</td><td>Jones</td><td>Paris</td></tr>
<tr><td>S3</td><td>Blake</td><td>Paris</td></tr>
<tr><td>S4</td><td>Clark</td><td>London</td></tr>
<tr><td>S5</td><td>Adams</td><td>Athens</td></tr>
</tbody>
</table>
<p class="clear">&nbsp;</p>
<p>If we take just the two attributes [SNO, SNAME] from each tuple of SX and SY, we see they are identical. This type of redundancy also leads to update
 anomalies. The principle of orthogonal design can be put this way:</p>
<p><i>The principle of Orthogonal Design:</i> If <i>A</i> and <i>B</i> are distinct relvars in the same database, then there must not exist nonlossless
 decompositions of <i>A</i> and <i>B</i> into <i>A1</i>, <i>A2</i>, ... <i>Am</i> and <i>B1</i>, <i>B2</i>, ... <i>Bm</i>, respectively, such that the
relvar constraints for some projection <i>Ai</i> in the set <i>A1</i>, <i>A2</i>, ... <i>Am</i> and some projection <i>Bj</i> in the set <i>B1</i>,
 <i>B2</i>, ... <i>Bm</i>, permit the same tuple to appear in both.</p> 
<p>That is, such decompositions "must not exist" because they introduce redundacy across the resulting relvars. Since one "nonloss decomposition" is the
 identity projection (the projection of a relvar on all its attributes), this definition also covers the case illustrated by the first example of SA and
 SB.</p>
<p>Like the principles of normalization, the principle of Orthogonal Design is basically just common sense. Normalization is intended to reduce
redundancy within relvars, and the principle of orthogonality is intended to reduce redundancy across relvars.</p>
<p>The example of SX and SY illustrates a lossless decomposition of S. SX is the projection S { SNO, SNAME, STATUS}, and SY is the projection S {SNO, SNAME,
 CITY }. Both SX and SY are in 5NF. Yet the decomposition is bad because SX and SY contain duplicate tuples.</p>
<h1>TO DO:</h1>
<p>
<ol>
<li>Add key points from lesson 8 and 9, having to do with PHP/SQL implementation issues:
<ol>
<li>protecting against injection attacks</li>
<li>???</li>
</li>
</ol>
</body></html>
